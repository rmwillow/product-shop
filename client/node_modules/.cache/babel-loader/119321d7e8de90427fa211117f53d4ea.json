{"ast":null,"code":"var url = require(\"url\");\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar assert = require(\"assert\");\n\nvar Writable = require(\"stream\").Writable;\n\nvar debug = require(\"debug\")(\"follow-redirects\"); // RFC7231§4.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\n\n\nvar SAFE_METHODS = {\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  TRACE: true\n}; // Create handlers that pass events from native requests\n\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n}); // An HTTP(S) request that can be redirected\n\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = []; // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n\n    delete options.host;\n  } // Attach a callback if passed\n\n\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  } // React to responses of native requests\n\n\n  var self = this;\n\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  }; // Complete the URL object when necessary\n\n\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  } // Perform the first request\n\n\n  this._performRequest();\n}\n\nRedirectableRequest.prototype = Object.create(Writable.prototype); // Writes buffered data to the current native request\n\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && \"length\" in data)) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n\n\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Only write when we don't exceed the maximum body length\n\n\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n\n    this._currentRequest.write(data, encoding, callback);\n  } // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n}; // Ends the current native request\n\n\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Write data and end\n\n\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n}; // Sets a header value on the current native request\n\n\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n\n  this._currentRequest.setHeader(name, value);\n}; // Clears a header value on the current native request\n\n\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n\n  this._currentRequest.removeHeader(name);\n}; // Proxy all other public ClientRequest methods\n\n\n[\"abort\", \"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n}); // Proxy all public ClientRequest properties\n\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n}); // Executes the next native request (initial or redirect)\n\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  } // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n\n\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  } // Create the native request\n\n\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options); // Set up event handlers\n\n  request._redirectable = this;\n\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  } // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n\n\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      } else {\n        request.end();\n      }\n    })();\n  }\n}; // Processes a response from the current native request\n\n\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode\n    });\n  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n\n  var location = response.headers.location;\n\n  if (location && this._options.followRedirects !== false && response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    } // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe […],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n\n\n    var header;\n    var headers = this._options.headers;\n\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\"; // Drop a possible entity and headers related to it\n\n      this._requestBodyBuffers = [];\n\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    } // Drop the Host header, as the redirect might lead to a different host\n\n\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    } // Perform the redirected request\n\n\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n\n    this._performRequest(); // Discard the remainder of the response to avoid waiting for data\n\n\n    response.destroy();\n  } else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response); // Clean up\n\n    this._requestBodyBuffers = [];\n  }\n}; // Wraps the key/value object of protocols with redirect functionality\n\n\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  }; // Wrap each protocol\n\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects\n\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      } else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength\n        }, options);\n      }\n\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }; // Executes a GET request, following redirects\n\n\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n} // Exports\n\n\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/follow-redirects/index.js"],"names":["url","require","http","https","assert","Writable","debug","SAFE_METHODS","GET","HEAD","OPTIONS","TRACE","eventHandlers","Object","create","forEach","event","arg","_redirectable","emit","RedirectableRequest","options","responseCallback","call","headers","_options","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","host","hostname","on","self","_onNativeResponse","response","_processResponse","pathname","path","searchPos","indexOf","substring","search","_performRequest","prototype","write","data","encoding","callback","Error","length","maxBodyLength","push","_currentRequest","abort","end","currentRequest","setHeader","name","value","removeHeader","method","a","b","property","defineProperty","get","protocol","nativeProtocol","nativeProtocols","agents","scheme","substr","agent","request","_currentUrl","format","_isRedirect","i","buffers","writeNext","buffer","trackRedirects","statusCode","location","followRedirects","maxRedirects","header","test","redirectUrl","resolve","assign","parse","destroy","responseUrl","redirects","wrap","protocols","exports","keys","wrappedProtocol","equal","module"],"mappings":"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","sourcesContent":["var url = require(\"url\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar assert = require(\"assert\");\nvar Writable = require(\"stream\").Writable;\nvar debug = require(\"debug\")(\"follow-redirects\");\n\n// RFC7231§4.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data and end\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe […],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n"]},"metadata":{},"sourceType":"script"}