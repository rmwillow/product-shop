{"ast":null,"code":"/*!\n * to-regex-range <https://github.com/jonschlinkert/to-regex-range>\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nvar repeat = require('repeat-string');\n\nvar isNumber = require('is-number');\n\nvar cache = {};\n\nfunction toRegexRange(min, max, options) {\n  if (isNumber(min) === false) {\n    throw new RangeError('toRegexRange: first argument is invalid.');\n  }\n\n  if (typeof max === 'undefined' || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new RangeError('toRegexRange: second argument is invalid.');\n  }\n\n  options = options || {};\n  var relax = String(options.relaxZeros);\n  var shorthand = String(options.shorthand);\n  var capture = String(options.capture);\n  var key = min + ':' + max + '=' + relax + shorthand + capture;\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key].result;\n  }\n\n  var a = Math.min(min, max);\n  var b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    var result = min + '|' + max;\n\n    if (options.capture) {\n      return '(' + result + ')';\n    }\n\n    return result;\n  }\n\n  var isPadded = padding(min) || padding(max);\n  var positives = [];\n  var negatives = [];\n  var tok = {\n    min: min,\n    max: max,\n    a: a,\n    b: b\n  };\n\n  if (isPadded) {\n    tok.isPadded = isPadded;\n    tok.maxLen = String(tok.max).length;\n  }\n\n  if (a < 0) {\n    var newMin = b < 0 ? Math.abs(b) : 1;\n    var newMax = Math.abs(a);\n    negatives = splitToPatterns(newMin, newMax, tok, options);\n    a = tok.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, tok, options);\n  }\n\n  tok.negatives = negatives;\n  tok.positives = positives;\n  tok.result = siftPatterns(negatives, positives, options);\n\n  if (options.capture && positives.length + negatives.length > 1) {\n    tok.result = '(' + tok.result + ')';\n  }\n\n  cache[key] = tok;\n  return tok.result;\n}\n\nfunction siftPatterns(neg, pos, options) {\n  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  min = Number(min);\n  max = Number(max);\n  var nines = 1;\n  var stops = [max];\n  var stop = +countNines(min, nines);\n\n  while (min <= stop && stop <= max) {\n    stops = push(stops, stop);\n    nines += 1;\n    stop = +countNines(min, nines);\n  }\n\n  var zeros = 1;\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops = push(stops, stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: String(start),\n      digits: []\n    };\n  }\n\n  var zipped = zip(String(start), String(stop));\n  var len = zipped.length,\n      i = -1;\n  var pattern = '';\n  var digits = 0;\n\n  while (++i < len) {\n    var numbers = zipped[i];\n    var startDigit = numbers[0];\n    var stopDigit = numbers[1];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      digits += 1;\n    }\n  }\n\n  if (digits) {\n    pattern += options.shorthand ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern: pattern,\n    digits: [digits]\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  var ranges = splitToRanges(min, max);\n  var len = ranges.length;\n  var idx = -1;\n  var tokens = [];\n  var start = min;\n  var prev;\n\n  while (++idx < len) {\n    var range = ranges[idx];\n    var obj = rangeToPattern(start, range, options);\n    var zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.digits.length > 1) {\n        prev.digits.pop();\n      }\n\n      prev.digits.push(obj.digits[0]);\n      prev.string = prev.pattern + toQuantifier(prev.digits);\n      start = range + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(range, tok);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);\n    tokens.push(obj);\n    start = range + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var tok = arr[i];\n    var ele = tok.string;\n\n    if (options.relaxZeros !== false) {\n      if (prefix === '-' && ele.charAt(0) === '0') {\n        if (ele.charAt(1) === '{') {\n          ele = '0*' + ele.replace(/^0\\{\\d+\\}/, '');\n        } else {\n          ele = '0*' + ele.slice(1);\n        }\n      }\n    }\n\n    if (!intersection && !contains(comparison, 'string', ele)) {\n      res.push(prefix + ele);\n    }\n\n    if (intersection && contains(comparison, 'string', ele)) {\n      res.push(prefix + ele);\n    }\n  }\n\n  return res;\n}\n/**\n * Zip strings (`for in` can be used on string characters)\n */\n\n\nfunction zip(a, b) {\n  var arr = [];\n\n  for (var ch in a) arr.push([a[ch], b[ch]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction push(arr, ele) {\n  if (arr.indexOf(ele) === -1) arr.push(ele);\n  return arr;\n}\n\nfunction contains(arr, key, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i][key] === val) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction countNines(min, len) {\n  return String(min).slice(0, -len) + repeat('9', len);\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  var start = digits[0];\n  var stop = digits[1] ? ',' + digits[1] : '';\n\n  if (!stop && (!start || start === 1)) {\n    return '';\n  }\n\n  return '{' + start + stop + '}';\n}\n\nfunction toCharacterClass(a, b) {\n  return '[' + a + (b - a === 1 ? '' : '-') + b + ']';\n}\n\nfunction padding(str) {\n  return /^-?(0+)\\d/.exec(str);\n}\n\nfunction padZeros(val, tok) {\n  if (tok.isPadded) {\n    var diff = Math.abs(tok.maxLen - String(val).length);\n\n    switch (diff) {\n      case 0:\n        return '';\n\n      case 1:\n        return '0';\n\n      default:\n        {\n          return '0{' + diff + '}';\n        }\n    }\n  }\n\n  return val;\n}\n/**\n * Expose `toRegexRange`\n */\n\n\nmodule.exports = toRegexRange;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/to-regex-range/index.js"],"names":["repeat","require","isNumber","cache","toRegexRange","min","max","options","RangeError","String","relax","relaxZeros","shorthand","capture","key","hasOwnProperty","result","a","Math","b","abs","isPadded","padding","positives","negatives","tok","maxLen","length","newMin","newMax","splitToPatterns","siftPatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","concat","join","splitToRanges","Number","nines","stops","stop","countNines","push","zeros","countZeros","sort","compare","rangeToPattern","start","pattern","digits","zipped","zip","len","i","numbers","startDigit","stopDigit","toCharacterClass","ranges","idx","tokens","prev","range","obj","pop","string","toQuantifier","padZeros","arr","comparison","prefix","intersection","res","ele","charAt","replace","slice","contains","ch","indexOf","val","integer","pow","str","exec","diff","module","exports"],"mappings":"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","sourcesContent":["/*!\n * to-regex-range <https://github.com/jonschlinkert/to-regex-range>\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar repeat = require('repeat-string');\nvar isNumber = require('is-number');\nvar cache = {};\n\nfunction toRegexRange(min, max, options) {\n  if (isNumber(min) === false) {\n    throw new RangeError('toRegexRange: first argument is invalid.');\n  }\n\n  if (typeof max === 'undefined' || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new RangeError('toRegexRange: second argument is invalid.');\n  }\n\n  options = options || {};\n  var relax = String(options.relaxZeros);\n  var shorthand = String(options.shorthand);\n  var capture = String(options.capture);\n  var key = min + ':' + max + '=' + relax + shorthand + capture;\n  if (cache.hasOwnProperty(key)) {\n    return cache[key].result;\n  }\n\n  var a = Math.min(min, max);\n  var b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    var result = min + '|' + max;\n    if (options.capture) {\n      return '(' + result + ')';\n    }\n    return result;\n  }\n\n  var isPadded = padding(min) || padding(max);\n  var positives = [];\n  var negatives = [];\n\n  var tok = {min: min, max: max, a: a, b: b};\n  if (isPadded) {\n    tok.isPadded = isPadded;\n    tok.maxLen = String(tok.max).length;\n  }\n\n  if (a < 0) {\n    var newMin = b < 0 ? Math.abs(b) : 1;\n    var newMax = Math.abs(a);\n    negatives = splitToPatterns(newMin, newMax, tok, options);\n    a = tok.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, tok, options);\n  }\n\n  tok.negatives = negatives;\n  tok.positives = positives;\n  tok.result = siftPatterns(negatives, positives, options);\n\n  if (options.capture && (positives.length + negatives.length) > 1) {\n    tok.result = '(' + tok.result + ')';\n  }\n\n  cache[key] = tok;\n  return tok.result;\n}\n\nfunction siftPatterns(neg, pos, options) {\n  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  min = Number(min);\n  max = Number(max);\n\n  var nines = 1;\n  var stops = [max];\n  var stop = +countNines(min, nines);\n\n  while (min <= stop && stop <= max) {\n    stops = push(stops, stop);\n    nines += 1;\n    stop = +countNines(min, nines);\n  }\n\n  var zeros = 1;\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops = push(stops, stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {pattern: String(start), digits: []};\n  }\n\n  var zipped = zip(String(start), String(stop));\n  var len = zipped.length, i = -1;\n\n  var pattern = '';\n  var digits = 0;\n\n  while (++i < len) {\n    var numbers = zipped[i];\n    var startDigit = numbers[0];\n    var stopDigit = numbers[1];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      digits += 1;\n    }\n  }\n\n  if (digits) {\n    pattern += options.shorthand ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern: pattern, digits: [digits] };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  var ranges = splitToRanges(min, max);\n  var len = ranges.length;\n  var idx = -1;\n\n  var tokens = [];\n  var start = min;\n  var prev;\n\n  while (++idx < len) {\n    var range = ranges[idx];\n    var obj = rangeToPattern(start, range, options);\n    var zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.digits.length > 1) {\n        prev.digits.pop();\n      }\n      prev.digits.push(obj.digits[0]);\n      prev.string = prev.pattern + toQuantifier(prev.digits);\n      start = range + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(range, tok);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);\n    tokens.push(obj);\n    start = range + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var tok = arr[i];\n    var ele = tok.string;\n\n    if (options.relaxZeros !== false) {\n      if (prefix === '-' && ele.charAt(0) === '0') {\n        if (ele.charAt(1) === '{') {\n          ele = '0*' + ele.replace(/^0\\{\\d+\\}/, '');\n        } else {\n          ele = '0*' + ele.slice(1);\n        }\n      }\n    }\n\n    if (!intersection && !contains(comparison, 'string', ele)) {\n      res.push(prefix + ele);\n    }\n\n    if (intersection && contains(comparison, 'string', ele)) {\n      res.push(prefix + ele);\n    }\n  }\n  return res;\n}\n\n/**\n * Zip strings (`for in` can be used on string characters)\n */\n\nfunction zip(a, b) {\n  var arr = [];\n  for (var ch in a) arr.push([a[ch], b[ch]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction push(arr, ele) {\n  if (arr.indexOf(ele) === -1) arr.push(ele);\n  return arr;\n}\n\nfunction contains(arr, key, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i][key] === val) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction countNines(min, len) {\n  return String(min).slice(0, -len) + repeat('9', len);\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  var start = digits[0];\n  var stop = digits[1] ? (',' + digits[1]) : '';\n  if (!stop && (!start || start === 1)) {\n    return '';\n  }\n  return '{' + start + stop + '}';\n}\n\nfunction toCharacterClass(a, b) {\n  return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';\n}\n\nfunction padding(str) {\n  return /^-?(0+)\\d/.exec(str);\n}\n\nfunction padZeros(val, tok) {\n  if (tok.isPadded) {\n    var diff = Math.abs(tok.maxLen - String(val).length);\n    switch (diff) {\n      case 0:\n        return '';\n      case 1:\n        return '0';\n      default: {\n        return '0{' + diff + '}';\n      }\n    }\n  }\n  return val;\n}\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n"]},"metadata":{},"sourceType":"script"}