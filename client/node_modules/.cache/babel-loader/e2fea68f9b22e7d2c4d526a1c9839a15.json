{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nmodule.exports = function (braces, options) {\n  braces.compiler\n  /**\n   * bos\n   */\n  .set('bos', function () {\n    if (this.output) return;\n    this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];\n    this.ast.count = 1;\n  })\n  /**\n   * Square brackets\n   */\n  .set('bracket', function (node) {\n    var close = node.close;\n    var open = !node.escaped ? '[' : '\\\\[';\n    var negated = node.negated;\n    var inner = node.inner;\n    inner = inner.replace(/\\\\(?=[\\\\\\w]|$)/g, '\\\\\\\\');\n\n    if (inner === ']-') {\n      inner = '\\\\]\\\\-';\n    }\n\n    if (negated && inner.indexOf('.') === -1) {\n      inner += '.';\n    }\n\n    if (negated && inner.indexOf('/') === -1) {\n      inner += '/';\n    }\n\n    var val = open + negated + inner + close;\n    var queue = node.parent.queue;\n    var last = utils.arrayify(queue.pop());\n    queue.push(utils.join(last, val));\n    queue.push.apply(queue, []);\n  })\n  /**\n   * Brace\n   */\n  .set('brace', function (node) {\n    node.queue = isEscaped(node) ? [node.val] : [];\n    node.count = 1;\n    return this.mapVisit(node.nodes);\n  })\n  /**\n   * Open\n   */\n  .set('brace.open', function (node) {\n    node.parent.open = node.val;\n  })\n  /**\n   * Inner\n   */\n  .set('text', function (node) {\n    var queue = node.parent.queue;\n    var escaped = node.escaped;\n    var segs = [node.val];\n\n    if (node.optimize === false) {\n      options = utils.extend({}, options, {\n        optimize: false\n      });\n    }\n\n    if (node.multiplier > 1) {\n      node.parent.count *= node.multiplier;\n    }\n\n    if (options.quantifiers === true && utils.isQuantifier(node.val)) {\n      escaped = true;\n    } else if (node.val.length > 1) {\n      if (isType(node.parent, 'brace') && !isEscaped(node)) {\n        var expanded = utils.expand(node.val, options);\n        segs = expanded.segs;\n\n        if (expanded.isOptimized) {\n          node.parent.isOptimized = true;\n        } // if nothing was expanded, we probably have a literal brace\n\n\n        if (!segs.length) {\n          var val = expanded.val || node.val;\n\n          if (options.unescape !== false) {\n            // unescape unexpanded brace sequence/set separators\n            val = val.replace(/\\\\([,.])/g, '$1'); // strip quotes\n\n            val = val.replace(/[\"'`]/g, '');\n          }\n\n          segs = [val];\n          escaped = true;\n        }\n      }\n    } else if (node.val === ',') {\n      if (options.expand) {\n        node.parent.queue.push(['']);\n        segs = [''];\n      } else {\n        segs = ['|'];\n      }\n    } else {\n      escaped = true;\n    }\n\n    if (escaped && isType(node.parent, 'brace')) {\n      if (node.parent.nodes.length <= 4 && node.parent.count === 1) {\n        node.parent.escaped = true;\n      } else if (node.parent.length <= 3) {\n        node.parent.escaped = true;\n      }\n    }\n\n    if (!hasQueue(node.parent)) {\n      node.parent.queue = segs;\n      return;\n    }\n\n    var last = utils.arrayify(queue.pop());\n\n    if (node.parent.count > 1 && options.expand) {\n      last = multiply(last, node.parent.count);\n      node.parent.count = 1;\n    }\n\n    queue.push(utils.join(utils.flatten(last), segs.shift()));\n    queue.push.apply(queue, segs);\n  })\n  /**\n   * Close\n   */\n  .set('brace.close', function (node) {\n    var queue = node.parent.queue;\n    var prev = node.parent.parent;\n    var last = prev.queue.pop();\n    var open = node.parent.open;\n    var close = node.val;\n\n    if (open && close && isOptimized(node, options)) {\n      open = '(';\n      close = ')';\n    } // if a close brace exists, and the previous segment is one character\n    // don't wrap the result in braces or parens\n\n\n    var ele = utils.last(queue);\n\n    if (node.parent.count > 1 && options.expand) {\n      ele = multiply(queue.pop(), node.parent.count);\n      node.parent.count = 1;\n      queue.push(ele);\n    }\n\n    if (close && typeof ele === 'string' && ele.length === 1) {\n      open = '';\n      close = '';\n    }\n\n    if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {\n      queue.push(utils.join(open, queue.pop() || ''));\n      queue = utils.flatten(utils.join(queue, close));\n    }\n\n    if (typeof last === 'undefined') {\n      prev.queue = [queue];\n    } else {\n      prev.queue.push(utils.flatten(utils.join(last, queue)));\n    }\n  })\n  /**\n   * eos\n   */\n  .set('eos', function (node) {\n    if (this.input) return;\n\n    if (options.optimize !== false) {\n      this.output = utils.last(utils.flatten(this.ast.queue));\n    } else if (Array.isArray(utils.last(this.ast.queue))) {\n      this.output = utils.flatten(this.ast.queue.pop());\n    } else {\n      this.output = utils.flatten(this.ast.queue);\n    }\n\n    if (node.parent.count > 1 && options.expand) {\n      this.output = multiply(this.output, node.parent.count);\n    }\n\n    this.output = utils.arrayify(this.output);\n    this.ast.queue = [];\n  });\n};\n/**\n * Multiply the segments in the current brace level\n */\n\n\nfunction multiply(queue, n, options) {\n  return utils.flatten(utils.repeat(utils.arrayify(queue), n));\n}\n/**\n * Return true if `node` is escaped\n */\n\n\nfunction isEscaped(node) {\n  return node.escaped === true;\n}\n/**\n * Returns true if regex parens should be used for sets. If the parent `type`\n * is not `brace`, then we're on a root node, which means we should never\n * expand segments and open/close braces should be `{}` (since this indicates\n * a brace is missing from the set)\n */\n\n\nfunction isOptimized(node, options) {\n  if (node.parent.isOptimized) return true;\n  return isType(node.parent, 'brace') && !isEscaped(node.parent) && options.expand !== true;\n}\n/**\n * Returns true if the value in `node` should be wrapped in a literal brace.\n * @return {Boolean}\n */\n\n\nfunction isLiteralBrace(node, options) {\n  return isEscaped(node.parent) || options.optimize !== false;\n}\n/**\n * Returns true if the given `node` does not have an inner value.\n * @return {Boolean}\n */\n\n\nfunction noInner(node, type) {\n  if (node.parent.queue.length === 1) {\n    return true;\n  }\n\n  var nodes = node.parent.nodes;\n  return nodes.length === 3 && isType(nodes[0], 'brace.open') && !isType(nodes[1], 'text') && isType(nodes[2], 'brace.close');\n}\n/**\n * Returns true if the given `node` is the given `type`\n * @return {Boolean}\n */\n\n\nfunction isType(node, type) {\n  return typeof node !== 'undefined' && node.type === type;\n}\n/**\n * Returns true if the given `node` has a non-empty queue.\n * @return {Boolean}\n */\n\n\nfunction hasQueue(node) {\n  return Array.isArray(node.queue) && node.queue.length;\n}","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/braces/lib/compilers.js"],"names":["utils","require","module","exports","braces","options","compiler","set","output","ast","queue","isEscaped","val","count","node","close","open","escaped","negated","inner","replace","indexOf","parent","last","arrayify","pop","push","join","apply","mapVisit","nodes","segs","optimize","extend","multiplier","quantifiers","isQuantifier","length","isType","expanded","expand","isOptimized","unescape","hasQueue","multiply","flatten","shift","prev","ele","isLiteralBrace","noInner","hasEmpty","input","Array","isArray","n","repeat","type"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\n\nmodule.exports = function(braces, options) {\n  braces.compiler\n\n    /**\n     * bos\n     */\n\n    .set('bos', function() {\n      if (this.output) return;\n      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];\n      this.ast.count = 1;\n    })\n\n    /**\n     * Square brackets\n     */\n\n    .set('bracket', function(node) {\n      var close = node.close;\n      var open = !node.escaped ? '[' : '\\\\[';\n      var negated = node.negated;\n      var inner = node.inner;\n\n      inner = inner.replace(/\\\\(?=[\\\\\\w]|$)/g, '\\\\\\\\');\n      if (inner === ']-') {\n        inner = '\\\\]\\\\-';\n      }\n\n      if (negated && inner.indexOf('.') === -1) {\n        inner += '.';\n      }\n      if (negated && inner.indexOf('/') === -1) {\n        inner += '/';\n      }\n\n      var val = open + negated + inner + close;\n      var queue = node.parent.queue;\n      var last = utils.arrayify(queue.pop());\n\n      queue.push(utils.join(last, val));\n      queue.push.apply(queue, []);\n    })\n\n    /**\n     * Brace\n     */\n\n    .set('brace', function(node) {\n      node.queue = isEscaped(node) ? [node.val] : [];\n      node.count = 1;\n      return this.mapVisit(node.nodes);\n    })\n\n    /**\n     * Open\n     */\n\n    .set('brace.open', function(node) {\n      node.parent.open = node.val;\n    })\n\n    /**\n     * Inner\n     */\n\n    .set('text', function(node) {\n      var queue = node.parent.queue;\n      var escaped = node.escaped;\n      var segs = [node.val];\n\n      if (node.optimize === false) {\n        options = utils.extend({}, options, {optimize: false});\n      }\n\n      if (node.multiplier > 1) {\n        node.parent.count *= node.multiplier;\n      }\n\n      if (options.quantifiers === true && utils.isQuantifier(node.val)) {\n        escaped = true;\n\n      } else if (node.val.length > 1) {\n        if (isType(node.parent, 'brace') && !isEscaped(node)) {\n          var expanded = utils.expand(node.val, options);\n          segs = expanded.segs;\n\n          if (expanded.isOptimized) {\n            node.parent.isOptimized = true;\n          }\n\n          // if nothing was expanded, we probably have a literal brace\n          if (!segs.length) {\n            var val = (expanded.val || node.val);\n            if (options.unescape !== false) {\n              // unescape unexpanded brace sequence/set separators\n              val = val.replace(/\\\\([,.])/g, '$1');\n              // strip quotes\n              val = val.replace(/[\"'`]/g, '');\n            }\n\n            segs = [val];\n            escaped = true;\n          }\n        }\n\n      } else if (node.val === ',') {\n        if (options.expand) {\n          node.parent.queue.push(['']);\n          segs = [''];\n        } else {\n          segs = ['|'];\n        }\n      } else {\n        escaped = true;\n      }\n\n      if (escaped && isType(node.parent, 'brace')) {\n        if (node.parent.nodes.length <= 4 && node.parent.count === 1) {\n          node.parent.escaped = true;\n        } else if (node.parent.length <= 3) {\n          node.parent.escaped = true;\n        }\n      }\n\n      if (!hasQueue(node.parent)) {\n        node.parent.queue = segs;\n        return;\n      }\n\n      var last = utils.arrayify(queue.pop());\n      if (node.parent.count > 1 && options.expand) {\n        last = multiply(last, node.parent.count);\n        node.parent.count = 1;\n      }\n\n      queue.push(utils.join(utils.flatten(last), segs.shift()));\n      queue.push.apply(queue, segs);\n    })\n\n    /**\n     * Close\n     */\n\n    .set('brace.close', function(node) {\n      var queue = node.parent.queue;\n      var prev = node.parent.parent;\n      var last = prev.queue.pop();\n      var open = node.parent.open;\n      var close = node.val;\n\n      if (open && close && isOptimized(node, options)) {\n        open = '(';\n        close = ')';\n      }\n\n      // if a close brace exists, and the previous segment is one character\n      // don't wrap the result in braces or parens\n      var ele = utils.last(queue);\n      if (node.parent.count > 1 && options.expand) {\n        ele = multiply(queue.pop(), node.parent.count);\n        node.parent.count = 1;\n        queue.push(ele);\n      }\n\n      if (close && typeof ele === 'string' && ele.length === 1) {\n        open = '';\n        close = '';\n      }\n\n      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {\n        queue.push(utils.join(open, queue.pop() || ''));\n        queue = utils.flatten(utils.join(queue, close));\n      }\n\n      if (typeof last === 'undefined') {\n        prev.queue = [queue];\n      } else {\n        prev.queue.push(utils.flatten(utils.join(last, queue)));\n      }\n    })\n\n    /**\n     * eos\n     */\n\n    .set('eos', function(node) {\n      if (this.input) return;\n\n      if (options.optimize !== false) {\n        this.output = utils.last(utils.flatten(this.ast.queue));\n      } else if (Array.isArray(utils.last(this.ast.queue))) {\n        this.output = utils.flatten(this.ast.queue.pop());\n      } else {\n        this.output = utils.flatten(this.ast.queue);\n      }\n\n      if (node.parent.count > 1 && options.expand) {\n        this.output = multiply(this.output, node.parent.count);\n      }\n\n      this.output = utils.arrayify(this.output);\n      this.ast.queue = [];\n    });\n\n};\n\n/**\n * Multiply the segments in the current brace level\n */\n\nfunction multiply(queue, n, options) {\n  return utils.flatten(utils.repeat(utils.arrayify(queue), n));\n}\n\n/**\n * Return true if `node` is escaped\n */\n\nfunction isEscaped(node) {\n  return node.escaped === true;\n}\n\n/**\n * Returns true if regex parens should be used for sets. If the parent `type`\n * is not `brace`, then we're on a root node, which means we should never\n * expand segments and open/close braces should be `{}` (since this indicates\n * a brace is missing from the set)\n */\n\nfunction isOptimized(node, options) {\n  if (node.parent.isOptimized) return true;\n  return isType(node.parent, 'brace')\n    && !isEscaped(node.parent)\n    && options.expand !== true;\n}\n\n/**\n * Returns true if the value in `node` should be wrapped in a literal brace.\n * @return {Boolean}\n */\n\nfunction isLiteralBrace(node, options) {\n  return isEscaped(node.parent) || options.optimize !== false;\n}\n\n/**\n * Returns true if the given `node` does not have an inner value.\n * @return {Boolean}\n */\n\nfunction noInner(node, type) {\n  if (node.parent.queue.length === 1) {\n    return true;\n  }\n  var nodes = node.parent.nodes;\n  return nodes.length === 3\n    && isType(nodes[0], 'brace.open')\n    && !isType(nodes[1], 'text')\n    && isType(nodes[2], 'brace.close');\n}\n\n/**\n * Returns true if the given `node` is the given `type`\n * @return {Boolean}\n */\n\nfunction isType(node, type) {\n  return typeof node !== 'undefined' && node.type === type;\n}\n\n/**\n * Returns true if the given `node` has a non-empty queue.\n * @return {Boolean}\n */\n\nfunction hasQueue(node) {\n  return Array.isArray(node.queue) && node.queue.length;\n}\n"]},"metadata":{},"sourceType":"script"}