{"ast":null,"code":"'use strict';\n\nvar utils = module.exports;\n\nvar path = require('path');\n/**\n * Module dependencies\n */\n\n\nvar Snapdragon = require('snapdragon');\n\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function () {\n  return path.sep === '\\\\' || process.platform === 'win32';\n};\n/**\n * Get the `Snapdragon` instance to use\n */\n\n\nutils.instantiate = function (ast, options) {\n  var snapdragon; // if an instance was created by `.parse`, use that instance\n\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon; // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon; // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function (str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str; // escape unmatched brace/bracket/parens\n\n    var last = this.parser.stack.pop();\n\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    } // add non-enumerable parser reference\n\n\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n  return snapdragon;\n};\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nutils.createKey = function (pattern, options) {\n  if (utils.typeOf(options) !== 'object') {\n    return pattern;\n  }\n\n  var val = pattern;\n  var keys = Object.keys(options);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    val += ';' + key + '=' + String(options[key]);\n  }\n\n  return val;\n};\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string') return [val];\n  return val ? Array.isArray(val) ? val : [val] : [];\n};\n/**\n * Return true if `val` is a non-empty string\n */\n\n\nutils.isString = function (val) {\n  return typeof val === 'string';\n};\n/**\n * Return true if `val` is a non-empty string\n */\n\n\nutils.isObject = function (val) {\n  return utils.typeOf(val) === 'object';\n};\n/**\n * Returns true if the given `str` has special characters\n */\n\n\nutils.hasSpecialChars = function (str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|\\[\\]{}]|[+@]\\()/.test(str);\n};\n/**\n * Escape regex characters in the given string\n */\n\n\nutils.escapeRegex = function (str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\\\/\\s]/g, '\\\\$&');\n};\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\n\nutils.toPosixPath = function (str) {\n  return str.replace(/\\\\+/g, '/');\n};\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\n\nutils.unescape = function (str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\n\nutils.stripPrefix = function (str) {\n  if (str.charAt(0) !== '.') {\n    return str;\n  }\n\n  var ch = str.charAt(1);\n\n  if (utils.isSlash(ch)) {\n    return str.slice(2);\n  }\n\n  return str;\n};\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\n\nutils.isSlash = function (str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.matchPath = function (pattern, options) {\n  return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);\n};\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\n\nutils._equals = function (filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\n\nutils._contains = function (filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.equalsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.containsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function (filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\n\nutils.matchBasename = function (re) {\n  return function (filepath) {\n    return re.test(path.basename(filepath));\n  };\n};\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\n\nutils.value = function (str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n\n  return unixify(str);\n};\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\n\nutils.unixify = function (options) {\n  options = options || {};\n  return function (filepath) {\n    if (utils.isWindows() || options.unixify === true) {\n      filepath = utils.toPosixPath(filepath);\n    }\n\n    if (options.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n\n    if (options.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n\n    return filepath;\n  };\n};","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/micromatch/lib/utils.js"],"names":["utils","module","exports","path","require","Snapdragon","define","diff","extend","pick","typeOf","unique","isWindows","sep","process","platform","instantiate","ast","options","snapdragon","str","parsed","prototype","parse","apply","arguments","input","last","parser","stack","pop","strictErrors","open","nodes","inner","type","val","charAt","sibling","parent","loose","createKey","pattern","keys","Object","i","length","key","String","arrayify","Array","isArray","isString","isObject","hasSpecialChars","test","escapeRegex","replace","toPosixPath","unescape","stripPrefix","ch","isSlash","slice","matchPath","contains","containsPattern","equalsPattern","_equals","filepath","unixPath","_contains","indexOf","unixify","fn","equal","nocase","lower","toLowerCase","matchBasename","re","basename","value"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = module.exports;\nvar path = require('path');\n\n/**\n * Module dependencies\n */\n\nvar Snapdragon = require('snapdragon');\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function() {\n  return path.sep === '\\\\' || process.platform === 'win32';\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function(ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n  // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon;\n  // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function(str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  if (utils.typeOf(options) !== 'object') {\n    return pattern;\n  }\n  var val = pattern;\n  var keys = Object.keys(options);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    val += ';' + key + '=' + String(options[key]);\n  }\n  return val;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === 'string') return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function(val) {\n  return typeof val === 'string';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function(val) {\n  return utils.typeOf(val) === 'object';\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function(str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|\\[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function(str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\\\/\\s]/g, '\\\\$&');\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function(str) {\n  return str.replace(/\\\\+/g, '/');\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function(str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function(str) {\n  if (str.charAt(0) !== '.') {\n    return str;\n  }\n  var ch = str.charAt(1);\n  if (utils.isSlash(ch)) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function(str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function(pattern, options) {\n  return (options && options.contains)\n    ? utils.containsPattern(pattern, options)\n    : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function(filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function(filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function(filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function(re) {\n  return function(filepath) {\n    return re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function(str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function(options) {\n  options = options || {};\n  return function(filepath) {\n    if (utils.isWindows() || options.unixify === true) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    if (options.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (options.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    return filepath;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}