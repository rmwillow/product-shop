{"ast":null,"code":"'use strict';\n\nvar nanomatch = require('nanomatch');\n\nvar extglob = require('extglob');\n\nmodule.exports = function (snapdragon) {\n  var compilers = snapdragon.compiler.compilers;\n  var opts = snapdragon.options; // register nanomatch compilers\n\n  snapdragon.use(nanomatch.compilers); // get references to some specific nanomatch compilers before they\n  // are overridden by the extglob and/or custom compilers\n\n  var escape = compilers.escape;\n  var qmark = compilers.qmark;\n  var slash = compilers.slash;\n  var star = compilers.star;\n  var text = compilers.text;\n  var plus = compilers.plus;\n  var dot = compilers.dot; // register extglob compilers or escape exglobs if disabled\n\n  if (opts.extglob === false || opts.noext === true) {\n    snapdragon.compiler.use(escapeExtglobs);\n  } else {\n    snapdragon.use(extglob.compilers);\n  }\n\n  snapdragon.use(function () {\n    this.options.star = this.options.star || function () {\n      return '[^\\\\\\\\/]*?';\n    };\n  }); // custom micromatch compilers\n\n  snapdragon.compiler // reset referenced compiler\n  .set('dot', dot).set('escape', escape).set('plus', plus).set('slash', slash).set('qmark', qmark).set('star', star).set('text', text);\n};\n\nfunction escapeExtglobs(compiler) {\n  compiler.set('paren', function (node) {\n    var val = '';\n    visit(node, function (tok) {\n      if (tok.val) val += (/^\\W/.test(tok.val) ? '\\\\' : '') + tok.val;\n    });\n    return this.emit(val, node);\n  });\n  /**\n   * Visit `node` with the given `fn`\n   */\n\n  function visit(node, fn) {\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  /**\n   * Map visit over array of `nodes`.\n   */\n\n\n  function mapVisit(nodes, fn) {\n    var len = nodes.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      visit(nodes[idx], fn);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/micromatch/lib/compilers.js"],"names":["nanomatch","require","extglob","module","exports","snapdragon","compilers","compiler","opts","options","use","escape","qmark","slash","star","text","plus","dot","noext","escapeExtglobs","set","node","val","visit","tok","test","emit","fn","nodes","mapVisit","len","length","idx"],"mappings":"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","sourcesContent":["'use strict';\n\nvar nanomatch = require('nanomatch');\nvar extglob = require('extglob');\n\nmodule.exports = function(snapdragon) {\n  var compilers = snapdragon.compiler.compilers;\n  var opts = snapdragon.options;\n\n  // register nanomatch compilers\n  snapdragon.use(nanomatch.compilers);\n\n  // get references to some specific nanomatch compilers before they\n  // are overridden by the extglob and/or custom compilers\n  var escape = compilers.escape;\n  var qmark = compilers.qmark;\n  var slash = compilers.slash;\n  var star = compilers.star;\n  var text = compilers.text;\n  var plus = compilers.plus;\n  var dot = compilers.dot;\n\n  // register extglob compilers or escape exglobs if disabled\n  if (opts.extglob === false || opts.noext === true) {\n    snapdragon.compiler.use(escapeExtglobs);\n  } else {\n    snapdragon.use(extglob.compilers);\n  }\n\n  snapdragon.use(function() {\n    this.options.star = this.options.star || function(/*node*/) {\n      return '[^\\\\\\\\/]*?';\n    };\n  });\n\n  // custom micromatch compilers\n  snapdragon.compiler\n\n    // reset referenced compiler\n    .set('dot', dot)\n    .set('escape', escape)\n    .set('plus', plus)\n    .set('slash', slash)\n    .set('qmark', qmark)\n    .set('star', star)\n    .set('text', text);\n};\n\nfunction escapeExtglobs(compiler) {\n  compiler.set('paren', function(node) {\n    var val = '';\n    visit(node, function(tok) {\n      if (tok.val) val += (/^\\W/.test(tok.val) ? '\\\\' : '') + tok.val;\n    });\n    return this.emit(val, node);\n  });\n\n  /**\n   * Visit `node` with the given `fn`\n   */\n\n  function visit(node, fn) {\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n\n  /**\n   * Map visit over array of `nodes`.\n   */\n\n  function mapVisit(nodes, fn) {\n    var len = nodes.length;\n    var idx = -1;\n    while (++idx < len) {\n      visit(nodes[idx], fn);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}