{"ast":null,"code":"'use strict';\n\nvar extend = require('extend-shallow');\n\nvar safe = require('safe-regex');\n/**\n * The main export is a function that takes a `pattern` string and an `options` object.\n *\n * ```js\n & var not = require('regex-not');\n & console.log(not('foo'));\n & //=> /^(?:(?!^(?:foo)$).)*$/\n * ```\n *\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.\n * @api public\n */\n\n\nfunction toRegex(pattern, options) {\n  return new RegExp(toRegex.create(pattern, options));\n}\n/**\n * Create a regex-compatible string from the given `pattern` and `options`.\n *\n * ```js\n & var not = require('regex-not');\n & console.log(not.create('foo'));\n & //=> '^(?:(?!^(?:foo)$).)*$'\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\n\ntoRegex.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var opts = extend({}, options);\n\n  if (opts.contains === true) {\n    opts.strictNegate = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var endChar = opts.endChar ? opts.endChar : '+';\n  var str = pattern;\n\n  if (opts.strictNegate === false) {\n    str = '(?:(?!(?:' + pattern + ')).)' + endChar;\n  } else {\n    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;\n  }\n\n  var res = open + str + close;\n\n  if (opts.safe === true && safe(res) === false) {\n    throw new Error('potentially unsafe regular expression: ' + res);\n  }\n\n  return res;\n};\n/**\n * Expose `toRegex`\n */\n\n\nmodule.exports = toRegex;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/regex-not/index.js"],"names":["extend","require","safe","toRegex","pattern","options","RegExp","create","TypeError","opts","contains","strictNegate","open","strictOpen","close","strictClose","endChar","str","res","Error","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,YAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,OAAT,CAAiBC,OAAjB,EAA0BC,OAA1B,EAAmC;AACjC,SAAO,IAAIC,MAAJ,CAAWH,OAAO,CAACI,MAAR,CAAeH,OAAf,EAAwBC,OAAxB,CAAX,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAF,OAAO,CAACI,MAAR,GAAiB,UAASH,OAAT,EAAkBC,OAAlB,EAA2B;AAC1C,MAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAII,SAAJ,CAAc,mBAAd,CAAN;AACD;;AAED,MAAIC,IAAI,GAAGT,MAAM,CAAC,EAAD,EAAKK,OAAL,CAAjB;;AACA,MAAII,IAAI,CAACC,QAAL,KAAkB,IAAtB,EAA4B;AAC1BD,IAAAA,IAAI,CAACE,YAAL,GAAoB,KAApB;AACD;;AAED,MAAIC,IAAI,GAAGH,IAAI,CAACI,UAAL,KAAoB,KAApB,GAA4B,GAA5B,GAAkC,EAA7C;AACA,MAAIC,KAAK,GAAGL,IAAI,CAACM,WAAL,KAAqB,KAArB,GAA6B,GAA7B,GAAmC,EAA/C;AACA,MAAIC,OAAO,GAAGP,IAAI,CAACO,OAAL,GAAeP,IAAI,CAACO,OAApB,GAA8B,GAA5C;AACA,MAAIC,GAAG,GAAGb,OAAV;;AAEA,MAAIK,IAAI,CAACE,YAAL,KAAsB,KAA1B,EAAiC;AAC/BM,IAAAA,GAAG,GAAG,cAAcb,OAAd,GAAwB,MAAxB,GAAiCY,OAAvC;AACD,GAFD,MAEO;AACLC,IAAAA,GAAG,GAAG,eAAeb,OAAf,GAAyB,OAAzB,GAAmCY,OAAzC;AACD;;AAED,MAAIE,GAAG,GAAGN,IAAI,GAAGK,GAAP,GAAaH,KAAvB;;AACA,MAAIL,IAAI,CAACP,IAAL,KAAc,IAAd,IAAsBA,IAAI,CAACgB,GAAD,CAAJ,KAAc,KAAxC,EAA+C;AAC7C,UAAM,IAAIC,KAAJ,CAAU,4CAA4CD,GAAtD,CAAN;AACD;;AAED,SAAOA,GAAP;AACD,CA3BD;AA6BA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiBlB,OAAjB","sourcesContent":["'use strict';\n\nvar extend = require('extend-shallow');\nvar safe = require('safe-regex');\n\n/**\n * The main export is a function that takes a `pattern` string and an `options` object.\n *\n * ```js\n & var not = require('regex-not');\n & console.log(not('foo'));\n & //=> /^(?:(?!^(?:foo)$).)*$/\n * ```\n *\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.\n * @api public\n */\n\nfunction toRegex(pattern, options) {\n  return new RegExp(toRegex.create(pattern, options));\n}\n\n/**\n * Create a regex-compatible string from the given `pattern` and `options`.\n *\n * ```js\n & var not = require('regex-not');\n & console.log(not.create('foo'));\n & //=> '^(?:(?!^(?:foo)$).)*$'\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\ntoRegex.create = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    opts.strictNegate = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var endChar = opts.endChar ? opts.endChar : '+';\n  var str = pattern;\n\n  if (opts.strictNegate === false) {\n    str = '(?:(?!(?:' + pattern + ')).)' + endChar;\n  } else {\n    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;\n  }\n\n  var res = open + str + close;\n  if (opts.safe === true && safe(res) === false) {\n    throw new Error('potentially unsafe regular expression: ' + res);\n  }\n\n  return res;\n};\n\n/**\n * Expose `toRegex`\n */\n\nmodule.exports = toRegex;\n"]},"metadata":{},"sourceType":"script"}