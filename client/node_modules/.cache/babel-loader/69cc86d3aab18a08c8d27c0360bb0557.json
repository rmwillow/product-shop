{"ast":null,"code":"// Note: source-map-resolve.js is generated from source-map-resolve-node.js and\n// source-map-resolve-template.js. Only edit the two latter files, _not_\n// source-map-resolve.js!\nvoid function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"source-map-url\", \"resolve-url\"], factory);\n  } else if (typeof exports === \"object\") {\n    var sourceMappingURL = require(\"source-map-url\");\n\n    var resolveUrl = require(\"resolve-url\");\n\n    module.exports = factory(sourceMappingURL, resolveUrl);\n  } else {\n    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl);\n  }\n}(this, function (sourceMappingURL, resolveUrl) {\n  function callbackAsync(callback, error, result) {\n    setImmediate(function () {\n      callback(error, result);\n    });\n  }\n\n  function parseMapToJSON(string, data) {\n    try {\n      return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n\n  function readSync(read, url, data) {\n    var readUrl = url;\n\n    try {\n      return String(read(readUrl));\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n  }\n\n  function resolveSourceMap(code, codeUrl, read, callback) {\n    var mapData;\n\n    try {\n      mapData = resolveSourceMapHelper(code, codeUrl);\n    } catch (error) {\n      return callbackAsync(callback, error);\n    }\n\n    if (!mapData || mapData.map) {\n      return callbackAsync(callback, null, mapData);\n    }\n\n    var readUrl = mapData.url;\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = mapData;\n        return callback(error);\n      }\n\n      mapData.map = String(result);\n\n      try {\n        mapData.map = parseMapToJSON(mapData.map, mapData);\n      } catch (error) {\n        return callback(error);\n      }\n\n      callback(null, mapData);\n    });\n  }\n\n  function resolveSourceMapSync(code, codeUrl, read) {\n    var mapData = resolveSourceMapHelper(code, codeUrl);\n\n    if (!mapData || mapData.map) {\n      return mapData;\n    }\n\n    mapData.map = readSync(read, mapData.url, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n    return mapData;\n  }\n\n  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n  /**\n   * The media type for JSON text is application/json.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n   *\n   * `text/json` is non-standard media type\n   */\n\n  var jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n  /**\n   * JSON text exchanged between systems that are not part of a closed ecosystem\n   * MUST be encoded using UTF-8.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n   */\n\n  var jsonCharacterEncoding = \"utf-8\";\n\n  function base64ToBuf(b64) {\n    var binStr = atob(b64);\n    var len = binStr.length;\n    var arr = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      arr[i] = binStr.charCodeAt(i);\n    }\n\n    return arr;\n  }\n\n  function decodeBase64String(b64) {\n    if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n      return atob(b64);\n    }\n\n    var buf = base64ToBuf(b64); // Note: `decoder.decode` method will throw a `DOMException` with the\n    // `\"EncodingError\"` value when an coding error is found.\n\n    var decoder = new TextDecoder(jsonCharacterEncoding, {\n      fatal: true\n    });\n    return decoder.decode(buf);\n  }\n\n  function resolveSourceMapHelper(code, codeUrl) {\n    var url = sourceMappingURL.getFrom(code);\n\n    if (!url) {\n      return null;\n    }\n\n    var dataUri = url.match(dataUriRegex);\n\n    if (dataUri) {\n      var mimeType = dataUri[1] || \"text/plain\";\n      var lastParameter = dataUri[2] || \"\";\n      var encoded = dataUri[3] || \"\";\n      var data = {\n        sourceMappingURL: url,\n        url: null,\n        sourcesRelativeTo: codeUrl,\n        map: encoded\n      };\n\n      if (!jsonMimeTypeRegex.test(mimeType)) {\n        var error = new Error(\"Unuseful data uri mime type: \" + mimeType);\n        error.sourceMapData = data;\n        throw error;\n      }\n\n      try {\n        data.map = parseMapToJSON(lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);\n      } catch (error) {\n        error.sourceMapData = data;\n        throw error;\n      }\n\n      return data;\n    }\n\n    var mapUrl = resolveUrl(codeUrl, url);\n    return {\n      sourceMappingURL: url,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n  }\n\n  function resolveSources(map, mapUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n\n    var pending = map.sources ? map.sources.length : 0;\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n\n    if (pending === 0) {\n      callbackAsync(callback, null, result);\n      return;\n    }\n\n    var done = function () {\n      pending--;\n\n      if (pending === 0) {\n        callback(null, result);\n      }\n    };\n\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n        callbackAsync(done, null);\n      } else {\n        var readUrl = fullUrl;\n        read(readUrl, function (error, source) {\n          result.sourcesContent[index] = error ? error : String(source);\n          done();\n        });\n      }\n    });\n  }\n\n  function resolveSourcesSync(map, mapUrl, read, options) {\n    var result = {\n      sourcesResolved: [],\n      sourcesContent: []\n    };\n\n    if (!map.sources || map.sources.length === 0) {\n      return result;\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl;\n\n      if (read !== null) {\n        if (typeof sourceContent === \"string\") {\n          result.sourcesContent[index] = sourceContent;\n        } else {\n          var readUrl = fullUrl;\n\n          try {\n            result.sourcesContent[index] = String(read(readUrl));\n          } catch (error) {\n            result.sourcesContent[index] = error;\n          }\n        }\n      }\n    });\n    return result;\n  }\n\n  var endingSlash = /\\/?$/;\n\n  function resolveSourcesHelper(map, mapUrl, options, fn) {\n    options = options || {};\n    var fullUrl;\n    var sourceContent;\n    var sourceRoot;\n\n    for (var index = 0, len = map.sources.length; index < len; index++) {\n      sourceRoot = null;\n\n      if (typeof options.sourceRoot === \"string\") {\n        sourceRoot = options.sourceRoot;\n      } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n        sourceRoot = map.sourceRoot;\n      } // If the sourceRoot is the empty string, it is equivalent to not setting\n      // the property at all.\n\n\n      if (sourceRoot === null || sourceRoot === '') {\n        fullUrl = resolveUrl(mapUrl, map.sources[index]);\n      } else {\n        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n        // does not make sense.\n        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n      }\n\n      sourceContent = (map.sourcesContent || [])[index];\n      fn(fullUrl, sourceContent, index);\n    }\n  }\n\n  function resolve(code, codeUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = {};\n    }\n\n    if (code === null) {\n      var mapUrl = codeUrl;\n      var data = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      var readUrl = mapUrl;\n      read(readUrl, function (error, result) {\n        if (error) {\n          error.sourceMapData = data;\n          return callback(error);\n        }\n\n        data.map = String(result);\n\n        try {\n          data.map = parseMapToJSON(data.map, data);\n        } catch (error) {\n          return callback(error);\n        }\n\n        _resolveSources(data);\n      });\n    } else {\n      resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!mapData) {\n          return callback(null, null);\n        }\n\n        _resolveSources(mapData);\n      });\n    }\n\n    function _resolveSources(mapData) {\n      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n        if (error) {\n          return callback(error);\n        }\n\n        mapData.sourcesResolved = result.sourcesResolved;\n        mapData.sourcesContent = result.sourcesContent;\n        callback(null, mapData);\n      });\n    }\n  }\n\n  function resolveSync(code, codeUrl, read, options) {\n    var mapData;\n\n    if (code === null) {\n      var mapUrl = codeUrl;\n      mapData = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      };\n      mapData.map = readSync(read, mapUrl, mapData);\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } else {\n      mapData = resolveSourceMapSync(code, codeUrl, read);\n\n      if (!mapData) {\n        return null;\n      }\n    }\n\n    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n    mapData.sourcesResolved = result.sourcesResolved;\n    mapData.sourcesContent = result.sourcesContent;\n    return mapData;\n  }\n\n  return {\n    resolveSourceMap: resolveSourceMap,\n    resolveSourceMapSync: resolveSourceMapSync,\n    resolveSources: resolveSources,\n    resolveSourcesSync: resolveSourcesSync,\n    resolve: resolve,\n    resolveSync: resolveSync,\n    parseMapToJSON: parseMapToJSON\n  };\n});","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/source-map-resolve/source-map-resolve.js"],"names":["root","factory","define","amd","exports","sourceMappingURL","require","resolveUrl","module","sourceMapResolve","callbackAsync","callback","error","result","setImmediate","parseMapToJSON","string","data","JSON","parse","replace","sourceMapData","readSync","read","url","readUrl","String","resolveSourceMap","code","codeUrl","mapData","resolveSourceMapHelper","map","resolveSourceMapSync","dataUriRegex","jsonMimeTypeRegex","jsonCharacterEncoding","base64ToBuf","b64","binStr","atob","len","length","arr","Uint8Array","i","charCodeAt","decodeBase64String","TextDecoder","buf","decoder","fatal","decode","getFrom","dataUri","match","mimeType","lastParameter","encoded","sourcesRelativeTo","test","Error","decodeURIComponent","mapUrl","resolveSources","options","pending","sources","sourcesResolved","sourcesContent","done","resolveSourcesHelper","fullUrl","sourceContent","index","source","resolveSourcesSync","endingSlash","fn","sourceRoot","resolve","_resolveSources","resolveSync"],"mappings":"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","sourcesContent":["// Note: source-map-resolve.js is generated from source-map-resolve-node.js and\n// source-map-resolve-template.js. Only edit the two latter files, _not_\n// source-map-resolve.js!\n\nvoid (function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"source-map-url\", \"resolve-url\"], factory)\n  } else if (typeof exports === \"object\") {\n    var sourceMappingURL = require(\"source-map-url\")\n    var resolveUrl = require(\"resolve-url\")\n    module.exports = factory(sourceMappingURL, resolveUrl)\n  } else {\n    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl)\n  }\n}(this, function(sourceMappingURL, resolveUrl) {\n\n  function callbackAsync(callback, error, result) {\n    setImmediate(function() { callback(error, result) })\n  }\n\n  function parseMapToJSON(string, data) {\n    try {\n      return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n  }\n\n  function readSync(read, url, data) {\n    var readUrl = url\n    try {\n      return String(read(readUrl))\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n  }\n\n\n\n  function resolveSourceMap(code, codeUrl, read, callback) {\n    var mapData\n    try {\n      mapData = resolveSourceMapHelper(code, codeUrl)\n    } catch (error) {\n      return callbackAsync(callback, error)\n    }\n    if (!mapData || mapData.map) {\n      return callbackAsync(callback, null, mapData)\n    }\n    var readUrl = mapData.url\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = mapData\n        return callback(error)\n      }\n      mapData.map = String(result)\n      try {\n        mapData.map = parseMapToJSON(mapData.map, mapData)\n      } catch (error) {\n        return callback(error)\n      }\n      callback(null, mapData)\n    })\n  }\n\n  function resolveSourceMapSync(code, codeUrl, read) {\n    var mapData = resolveSourceMapHelper(code, codeUrl)\n    if (!mapData || mapData.map) {\n      return mapData\n    }\n    mapData.map = readSync(read, mapData.url, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n    return mapData\n  }\n\n  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n\n  /**\n   * The media type for JSON text is application/json.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n   *\n   * `text/json` is non-standard media type\n   */\n  var jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n  /**\n   * JSON text exchanged between systems that are not part of a closed ecosystem\n   * MUST be encoded using UTF-8.\n   *\n   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n   */\n  var jsonCharacterEncoding = \"utf-8\"\n\n  function base64ToBuf(b64) {\n    var binStr = atob(b64)\n    var len = binStr.length\n    var arr = new Uint8Array(len)\n    for (var i = 0; i < len; i++) {\n      arr[i] = binStr.charCodeAt(i)\n    }\n    return arr\n  }\n\n  function decodeBase64String(b64) {\n    if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n      return atob(b64)\n    }\n    var buf = base64ToBuf(b64);\n    // Note: `decoder.decode` method will throw a `DOMException` with the\n    // `\"EncodingError\"` value when an coding error is found.\n    var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\n    return decoder.decode(buf);\n  }\n\n  function resolveSourceMapHelper(code, codeUrl) {\n    var url = sourceMappingURL.getFrom(code)\n    if (!url) {\n      return null\n    }\n\n    var dataUri = url.match(dataUriRegex)\n    if (dataUri) {\n      var mimeType = dataUri[1] || \"text/plain\"\n      var lastParameter = dataUri[2] || \"\"\n      var encoded = dataUri[3] || \"\"\n      var data = {\n        sourceMappingURL: url,\n        url: null,\n        sourcesRelativeTo: codeUrl,\n        map: encoded\n      }\n      if (!jsonMimeTypeRegex.test(mimeType)) {\n        var error = new Error(\"Unuseful data uri mime type: \" + mimeType)\n        error.sourceMapData = data\n        throw error\n      }\n      try {\n        data.map = parseMapToJSON(\n          lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded),\n          data\n        )\n      } catch (error) {\n        error.sourceMapData = data\n        throw error\n      }\n      return data\n    }\n\n    var mapUrl = resolveUrl(codeUrl, url)\n    return {\n      sourceMappingURL: url,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n  }\n\n\n\n  function resolveSources(map, mapUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options\n      options = {}\n    }\n    var pending = map.sources ? map.sources.length : 0\n    var result = {\n      sourcesResolved: [],\n      sourcesContent:  []\n    }\n\n    if (pending === 0) {\n      callbackAsync(callback, null, result)\n      return\n    }\n\n    var done = function() {\n      pending--\n      if (pending === 0) {\n        callback(null, result)\n      }\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent\n        callbackAsync(done, null)\n      } else {\n        var readUrl = fullUrl\n        read(readUrl, function(error, source) {\n          result.sourcesContent[index] = error ? error : String(source)\n          done()\n        })\n      }\n    })\n  }\n\n  function resolveSourcesSync(map, mapUrl, read, options) {\n    var result = {\n      sourcesResolved: [],\n      sourcesContent:  []\n    }\n\n    if (!map.sources || map.sources.length === 0) {\n      return result\n    }\n\n    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n      result.sourcesResolved[index] = fullUrl\n      if (read !== null) {\n        if (typeof sourceContent === \"string\") {\n          result.sourcesContent[index] = sourceContent\n        } else {\n          var readUrl = fullUrl\n          try {\n            result.sourcesContent[index] = String(read(readUrl))\n          } catch (error) {\n            result.sourcesContent[index] = error\n          }\n        }\n      }\n    })\n\n    return result\n  }\n\n  var endingSlash = /\\/?$/\n\n  function resolveSourcesHelper(map, mapUrl, options, fn) {\n    options = options || {}\n    var fullUrl\n    var sourceContent\n    var sourceRoot\n    for (var index = 0, len = map.sources.length; index < len; index++) {\n      sourceRoot = null\n      if (typeof options.sourceRoot === \"string\") {\n        sourceRoot = options.sourceRoot\n      } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n        sourceRoot = map.sourceRoot\n      }\n      // If the sourceRoot is the empty string, it is equivalent to not setting\n      // the property at all.\n      if (sourceRoot === null || sourceRoot === '') {\n        fullUrl = resolveUrl(mapUrl, map.sources[index])\n      } else {\n        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n        // does not make sense.\n        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\n      }\n      sourceContent = (map.sourcesContent || [])[index]\n      fn(fullUrl, sourceContent, index)\n    }\n  }\n\n\n\n  function resolve(code, codeUrl, read, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options\n      options = {}\n    }\n    if (code === null) {\n      var mapUrl = codeUrl\n      var data = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      }\n      var readUrl = mapUrl\n      read(readUrl, function(error, result) {\n        if (error) {\n          error.sourceMapData = data\n          return callback(error)\n        }\n        data.map = String(result)\n        try {\n          data.map = parseMapToJSON(data.map, data)\n        } catch (error) {\n          return callback(error)\n        }\n        _resolveSources(data)\n      })\n    } else {\n      resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n        if (error) {\n          return callback(error)\n        }\n        if (!mapData) {\n          return callback(null, null)\n        }\n        _resolveSources(mapData)\n      })\n    }\n\n    function _resolveSources(mapData) {\n      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n        if (error) {\n          return callback(error)\n        }\n        mapData.sourcesResolved = result.sourcesResolved\n        mapData.sourcesContent  = result.sourcesContent\n        callback(null, mapData)\n      })\n    }\n  }\n\n  function resolveSync(code, codeUrl, read, options) {\n    var mapData\n    if (code === null) {\n      var mapUrl = codeUrl\n      mapData = {\n        sourceMappingURL: null,\n        url: mapUrl,\n        sourcesRelativeTo: mapUrl,\n        map: null\n      }\n      mapData.map = readSync(read, mapUrl, mapData)\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } else {\n      mapData = resolveSourceMapSync(code, codeUrl, read)\n      if (!mapData) {\n        return null\n      }\n    }\n    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n    mapData.sourcesResolved = result.sourcesResolved\n    mapData.sourcesContent  = result.sourcesContent\n    return mapData\n  }\n\n\n\n  return {\n    resolveSourceMap:     resolveSourceMap,\n    resolveSourceMapSync: resolveSourceMapSync,\n    resolveSources:       resolveSources,\n    resolveSourcesSync:   resolveSourcesSync,\n    resolve:              resolve,\n    resolveSync:          resolveSync,\n    parseMapToJSON:       parseMapToJSON\n  }\n\n}));\n"]},"metadata":{},"sourceType":"script"}