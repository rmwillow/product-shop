{"ast":null,"code":"'use strict';\n\nvar extend = require('extend-shallow');\n\nvar Snapdragon = require('snapdragon');\n\nvar compilers = require('./compilers');\n\nvar parsers = require('./parsers');\n\nvar utils = require('./utils');\n/**\n * Customize Snapdragon parser and renderer\n */\n\n\nfunction Braces(options) {\n  this.options = extend({}, options);\n}\n/**\n * Initialize braces\n */\n\n\nBraces.prototype.init = function (options) {\n  if (this.isInitialized) return;\n  this.isInitialized = true;\n  var opts = utils.createOptions({}, this.options, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n  compilers(this.snapdragon, opts);\n  parsers(this.snapdragon, opts);\n  /**\n   * Call Snapdragon `.parse` method. When AST is returned, we check to\n   * see if any unclosed braces are left on the stack and, if so, we iterate\n   * over the stack and correct the AST so that compilers are called in the correct\n   * order and unbalance braces are properly escaped.\n   */\n\n  utils.define(this.snapdragon, 'parse', function (pattern, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    this.parser.ast.input = pattern;\n    var stack = this.parser.stack;\n\n    while (stack.length) {\n      addParent({\n        type: 'brace.close',\n        val: ''\n      }, stack.pop());\n    }\n\n    function addParent(node, parent) {\n      utils.define(node, 'parent', parent);\n      parent.nodes.push(node);\n    } // add non-enumerable parser reference\n\n\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n};\n/**\n * Decorate `.parse` method\n */\n\n\nBraces.prototype.parse = function (ast, options) {\n  if (ast && typeof ast === 'object' && ast.nodes) return ast;\n  this.init(options);\n  return this.snapdragon.parse(ast, options);\n};\n/**\n * Decorate `.compile` method\n */\n\n\nBraces.prototype.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = this.parse(ast, options);\n  } else {\n    this.init(options);\n  }\n\n  return this.snapdragon.compile(ast, options);\n};\n/**\n * Expand\n */\n\n\nBraces.prototype.expand = function (pattern) {\n  var ast = this.parse(pattern, {\n    expand: true\n  });\n  return this.compile(ast, {\n    expand: true\n  });\n};\n/**\n * Optimize\n */\n\n\nBraces.prototype.optimize = function (pattern) {\n  var ast = this.parse(pattern, {\n    optimize: true\n  });\n  return this.compile(ast, {\n    optimize: true\n  });\n};\n/**\n * Expose `Braces`\n */\n\n\nmodule.exports = Braces;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/braces/lib/braces.js"],"names":["extend","require","Snapdragon","compilers","parsers","utils","Braces","options","prototype","init","isInitialized","opts","createOptions","snapdragon","compiler","parser","define","pattern","parsed","parse","apply","arguments","ast","input","stack","length","addParent","type","val","pop","node","parent","nodes","push","compile","expand","optimize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar extend = require('extend-shallow');\nvar Snapdragon = require('snapdragon');\nvar compilers = require('./compilers');\nvar parsers = require('./parsers');\nvar utils = require('./utils');\n\n/**\n * Customize Snapdragon parser and renderer\n */\n\nfunction Braces(options) {\n  this.options = extend({}, options);\n}\n\n/**\n * Initialize braces\n */\n\nBraces.prototype.init = function(options) {\n  if (this.isInitialized) return;\n  this.isInitialized = true;\n  var opts = utils.createOptions({}, this.options, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n\n  compilers(this.snapdragon, opts);\n  parsers(this.snapdragon, opts);\n\n  /**\n   * Call Snapdragon `.parse` method. When AST is returned, we check to\n   * see if any unclosed braces are left on the stack and, if so, we iterate\n   * over the stack and correct the AST so that compilers are called in the correct\n   * order and unbalance braces are properly escaped.\n   */\n\n  utils.define(this.snapdragon, 'parse', function(pattern, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    this.parser.ast.input = pattern;\n\n    var stack = this.parser.stack;\n    while (stack.length) {\n      addParent({type: 'brace.close', val: ''}, stack.pop());\n    }\n\n    function addParent(node, parent) {\n      utils.define(node, 'parent', parent);\n      parent.nodes.push(node);\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n};\n\n/**\n * Decorate `.parse` method\n */\n\nBraces.prototype.parse = function(ast, options) {\n  if (ast && typeof ast === 'object' && ast.nodes) return ast;\n  this.init(options);\n  return this.snapdragon.parse(ast, options);\n};\n\n/**\n * Decorate `.compile` method\n */\n\nBraces.prototype.compile = function(ast, options) {\n  if (typeof ast === 'string') {\n    ast = this.parse(ast, options);\n  } else {\n    this.init(options);\n  }\n  return this.snapdragon.compile(ast, options);\n};\n\n/**\n * Expand\n */\n\nBraces.prototype.expand = function(pattern) {\n  var ast = this.parse(pattern, {expand: true});\n  return this.compile(ast, {expand: true});\n};\n\n/**\n * Optimize\n */\n\nBraces.prototype.optimize = function(pattern) {\n  var ast = this.parse(pattern, {optimize: true});\n  return this.compile(ast, {optimize: true});\n};\n\n/**\n * Expose `Braces`\n */\n\nmodule.exports = Braces;\n"]},"metadata":{},"sourceType":"script"}