{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar util = require('util');\n\nvar braces = require('braces');\n\nvar toRegex = require('to-regex');\n\nvar extend = require('extend-shallow');\n/**\n * Local dependencies\n */\n\n\nvar compilers = require('./lib/compilers');\n\nvar parsers = require('./lib/parsers');\n\nvar cache = require('./lib/cache');\n\nvar utils = require('./lib/utils');\n\nvar MAX_LENGTH = 1024 * 64;\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n  var len = patterns.length;\n\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33\n    /* ! */\n    ) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\n\nmicromatch.match = function (list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  } // if no options were passed, uniquify results and return\n\n\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  } // if `opts.ignore` was defined, diff ignored list\n\n\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\n\nmicromatch.isMatch = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.any = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\n\nmicromatch.not = function (list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n\n    if (equals(str)) {\n      return true;\n    }\n\n    var contains = utils.containsPattern(patterns, options);\n\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {\n    contains: true\n  });\n  return micromatch.any(str, patterns, opts);\n};\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\n\nmicromatch.matchBase = function (pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  } // if pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  } // if pattern is invalid\n\n\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  } // if pattern is a non-glob string\n\n\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n\n    return utils.matchPath(pattern, options);\n  } // if pattern is a glob string\n\n\n  var re = micromatch.makeRe(pattern, options); // if `options.matchBase` or `options.basename` is defined\n\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n    return function (str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = function (pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({\n    capture: true\n  }, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function (string) {\n      var match = re.exec(unixify(string));\n\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function (obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = function (pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n\n    return braces(pattern, options);\n  }\n\n  return memoize('braces', pattern, options, expand);\n};\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\n\nmicromatch.braceExpand = function (pattern, options) {\n  var opts = extend({}, options, {\n    expand: true\n  });\n  return micromatch.braces(pattern, opts);\n};\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\n\nmicromatch.create = function (pattern, options) {\n  return memoize('create', pattern, options, function () {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n\n    return res;\n  });\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nmicromatch.parse = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\n\nmicromatch.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, function () {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\n\nmicromatch.clearCache = function () {\n  micromatch.cache.caches = {};\n};\n/**\n * Returns true if the given value is effectively an empty string\n */\n\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n  return memoize('compose', String(patterns), options, function () {\n    return function (file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  });\n}\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/micromatch/index.js"],"names":["util","require","braces","toRegex","extend","compilers","parsers","cache","utils","MAX_LENGTH","micromatch","list","patterns","options","arrayify","len","length","match","omit","keep","idx","pattern","charCodeAt","push","apply","slice","matches","diff","nodupes","unique","Array","isArray","TypeError","unixify","isMatch","memoize","matcher","ele","value","failglob","Error","nonull","nullglob","unescape","ignore","not","str","inspect","isEmptyString","equals","equalsPattern","some","i","every","any","all","opts","map","contains","containsPattern","matchBase","indexOf","basename","matchKeys","obj","isObject","keys","Object","pick","compose","RegExp","test","isString","hasSpecialChars","nocase","toLowerCase","matchPath","re","makeRe","matchBasename","regex","fn","defineProperty","configurable","enumerable","result","capture","string","exec","create","ast_array","output","ast","state","join","expand","nobrace","braceExpand","compile","parse","res","snapdragon","instantiate","define","input","clearCache","caches","val","String","matchers","file","type","key","createKey","has","get","set","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar braces = require('braces');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nmicromatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nmicromatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.any = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return micromatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nmicromatch.matchBase = function(pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = micromatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = function(pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function(obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = function(pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n    return braces(pattern, options);\n  }\n\n  return memoize('braces', pattern, options, expand);\n};\n\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\nmicromatch.braceExpand = function(pattern, options) {\n  var opts = extend({}, options, {expand: true});\n  return micromatch.braces(pattern, opts);\n};\n\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nmicromatch.create = function(pattern, options) {\n  return memoize('create', pattern, options, function() {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n    return res;\n  });\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nmicromatch.parse = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nmicromatch.compile = function(ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, function() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\nmicromatch.clearCache = function() {\n  micromatch.cache.caches = {};\n};\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize('compose', String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;\n"]},"metadata":{},"sourceType":"script"}