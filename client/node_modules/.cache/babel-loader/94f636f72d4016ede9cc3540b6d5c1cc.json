{"ast":null,"code":"'use strict';\n\nvar Node = require('snapdragon-node');\n\nvar utils = require('./utils');\n/**\n * Braces parsers\n */\n\n\nmodule.exports = function (braces, options) {\n  braces.parser.set('bos', function () {\n    if (!this.parsed) {\n      this.ast = this.nodes[0] = new Node(this.ast);\n    }\n  })\n  /**\n   * Character parsers\n   */\n  .set('escape', function () {\n    var pos = this.position();\n    var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: m[0]\n    }));\n\n    if (node.val === '\\\\\\\\') {\n      return node;\n    }\n\n    if (node.val === '${') {\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n        node.val += ch;\n\n        if (ch === '\\\\') {\n          node.val += str[++idx];\n          continue;\n        }\n\n        if (ch === '}') {\n          break;\n        }\n      }\n    }\n\n    if (this.options.unescape !== false) {\n      node.val = node.val.replace(/\\\\([{}])/g, '$1');\n    }\n\n    if (last.val === '\"' && this.input.charAt(0) === '\"') {\n      last.val = node.val;\n      this.consume(1);\n      return;\n    }\n\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Brackets: \"[...]\" (basic, this is overridden by\n   * other parsers in more advanced implementations)\n   */\n  .set('bracket', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n    var negated = m[1] ? '^' : '';\n    var inner = m[2] || '';\n    var close = m[3] || '';\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var esc = this.input.slice(0, 2);\n\n    if (inner === '' && esc === '\\\\]') {\n      inner += esc;\n      this.consume(2);\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n\n        if (ch === ']') {\n          close = ch;\n          break;\n        }\n\n        inner += ch;\n      }\n    }\n\n    return pos(new Node({\n      type: 'bracket',\n      val: val,\n      escaped: close !== ']',\n      negated: negated,\n      inner: inner,\n      close: close\n    }));\n  })\n  /**\n   * Empty braces (we capture these early to\n   * speed up processing in the compiler)\n   */\n  .set('multiplier', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n    if (!m) return;\n    this.multiplier = true;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      match: m,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  })\n  /**\n   * Open\n   */\n  .set('brace.open', function () {\n    var pos = this.position();\n    var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n    if (!m) return;\n    var prev = this.prev();\n    var last = utils.last(prev.nodes); // if the last parsed character was an extglob character\n    // we need to _not optimize_ the brace pattern because\n    // it might be mistaken for an extglob by a downstream parser\n\n    if (last && last.val && isExtglobChar(last.val.slice(-1))) {\n      last.optimize = false;\n    }\n\n    var open = pos(new Node({\n      type: 'brace.open',\n      val: m[0]\n    }));\n    var node = pos(new Node({\n      type: 'brace',\n      nodes: []\n    }));\n    node.push(open);\n    prev.push(node);\n    this.push('brace', node);\n  })\n  /**\n   * Close\n   */\n  .set('brace.close', function () {\n    var pos = this.position();\n    var m = this.match(/^\\}/);\n    if (!m || !m[0]) return;\n    var brace = this.pop('brace');\n    var node = pos(new Node({\n      type: 'brace.close',\n      val: m[0]\n    }));\n\n    if (!this.isType(brace, 'brace')) {\n      if (this.options.strict) {\n        throw new Error('missing opening \"{\"');\n      }\n\n      node.type = 'text';\n      node.multiplier = 0;\n      node.escaped = true;\n      return node;\n    }\n\n    var prev = this.prev();\n    var last = utils.last(prev.nodes);\n\n    if (last.text) {\n      var lastNode = utils.last(last.nodes);\n\n      if (lastNode.val === ')' && /[!@*?+]\\(/.test(last.text)) {\n        var open = last.nodes[0];\n        var text = last.nodes[1];\n\n        if (open.type === 'brace.open' && text && text.type === 'text') {\n          text.optimize = false;\n        }\n      }\n    }\n\n    if (brace.nodes.length > 2) {\n      var first = brace.nodes[1];\n\n      if (first.type === 'text' && first.val === ',') {\n        brace.nodes.splice(1, 1);\n        brace.nodes.push(first);\n      }\n    }\n\n    brace.push(node);\n  })\n  /**\n   * Capture boundary characters\n   */\n  .set('boundary', function () {\n    var pos = this.position();\n    var m = this.match(/^[$^](?!\\{)/);\n    if (!m) return;\n    return pos(new Node({\n      type: 'text',\n      val: m[0]\n    }));\n  })\n  /**\n   * One or zero, non-comma characters wrapped in braces\n   */\n  .set('nobrace', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^\\{[^,]?\\}/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    return pos(new Node({\n      type: 'text',\n      multiplier: 0,\n      val: val\n    }));\n  })\n  /**\n   * Text\n   */\n  .set('text', function () {\n    var isInside = this.isInside('brace');\n    var pos = this.position();\n    var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n    if (!m) return;\n    var prev = this.prev();\n    var val = m[0];\n\n    if (isInside && prev.type === 'brace') {\n      prev.text = prev.text || '';\n      prev.text += val;\n    }\n\n    var node = pos(new Node({\n      type: 'text',\n      multiplier: 1,\n      val: val\n    }));\n    return concatNodes.call(this, pos, node, prev, options);\n  });\n};\n/**\n * Returns true if the character is an extglob character.\n */\n\n\nfunction isExtglobChar(ch) {\n  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';\n}\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length > 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n    isEscaped = a === '\"' && b === '\"' || a === \"'\" && b === \"'\" || a === '`' && b === '`';\n  }\n\n  if (isEscaped && options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n\n    if (!match || match.indexOf('}') === -1) {\n      match = node.match[0];\n    } // replace each set with a single \",\"\n\n\n    var val = match.replace(/\\{/g, ',').replace(/\\}/g, '');\n    node.multiplier *= val.length;\n    node.val = '';\n  }\n\n  var simpleText = last.type === 'text' && last.multiplier === 1 && node.multiplier === 1 && node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/braces/lib/parsers.js"],"names":["Node","require","utils","module","exports","braces","options","parser","set","parsed","ast","nodes","pos","position","m","match","prev","last","node","type","multiplier","val","str","input","idx","ch","consume","unescape","replace","charAt","concatNodes","call","isInside","negated","inner","close","text","esc","slice","escaped","isExtglobChar","optimize","open","push","brace","pop","isType","strict","Error","lastNode","test","length","first","splice","parent","orig","isEscaped","a","b","indexOf","simpleText"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Node = require('snapdragon-node');\nvar utils = require('./utils');\n\n/**\n * Braces parsers\n */\n\nmodule.exports = function(braces, options) {\n  braces.parser\n    .set('bos', function() {\n      if (!this.parsed) {\n        this.ast = this.nodes[0] = new Node(this.ast);\n      }\n    })\n\n    /**\n     * Character parsers\n     */\n\n    .set('escape', function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        val: m[0]\n      }));\n\n      if (node.val === '\\\\\\\\') {\n        return node;\n      }\n\n      if (node.val === '${') {\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          node.val += ch;\n          if (ch === '\\\\') {\n            node.val += str[++idx];\n            continue;\n          }\n          if (ch === '}') {\n            break;\n          }\n        }\n      }\n\n      if (this.options.unescape !== false) {\n        node.val = node.val.replace(/\\\\([{}])/g, '$1');\n      }\n\n      if (last.val === '\"' && this.input.charAt(0) === '\"') {\n        last.val = node.val;\n        this.consume(1);\n        return;\n      }\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Brackets: \"[...]\" (basic, this is overridden by\n     * other parsers in more advanced implementations)\n     */\n\n    .set('bracket', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n      var negated = m[1] ? '^' : '';\n      var inner = m[2] || '';\n      var close = m[3] || '';\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === '' && esc === '\\\\]') {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === ']') {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos(new Node({\n        type: 'bracket',\n        val: val,\n        escaped: close !== ']',\n        negated: negated,\n        inner: inner,\n        close: close\n      }));\n    })\n\n    /**\n     * Empty braces (we capture these early to\n     * speed up processing in the compiler)\n     */\n\n    .set('multiplier', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n      if (!m) return;\n\n      this.multiplier = true;\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        match: m,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Open\n     */\n\n    .set('brace.open', function() {\n      var pos = this.position();\n      var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      // if the last parsed character was an extglob character\n      // we need to _not optimize_ the brace pattern because\n      // it might be mistaken for an extglob by a downstream parser\n      if (last && last.val && isExtglobChar(last.val.slice(-1))) {\n        last.optimize = false;\n      }\n\n      var open = pos(new Node({\n        type: 'brace.open',\n        val: m[0]\n      }));\n\n      var node = pos(new Node({\n        type: 'brace',\n        nodes: []\n      }));\n\n      node.push(open);\n      prev.push(node);\n      this.push('brace', node);\n    })\n\n    /**\n     * Close\n     */\n\n    .set('brace.close', function() {\n      var pos = this.position();\n      var m = this.match(/^\\}/);\n      if (!m || !m[0]) return;\n\n      var brace = this.pop('brace');\n      var node = pos(new Node({\n        type: 'brace.close',\n        val: m[0]\n      }));\n\n      if (!this.isType(brace, 'brace')) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"{\"');\n        }\n        node.type = 'text';\n        node.multiplier = 0;\n        node.escaped = true;\n        return node;\n      }\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n      if (last.text) {\n        var lastNode = utils.last(last.nodes);\n        if (lastNode.val === ')' && /[!@*?+]\\(/.test(last.text)) {\n          var open = last.nodes[0];\n          var text = last.nodes[1];\n          if (open.type === 'brace.open' && text && text.type === 'text') {\n            text.optimize = false;\n          }\n        }\n      }\n\n      if (brace.nodes.length > 2) {\n        var first = brace.nodes[1];\n        if (first.type === 'text' && first.val === ',') {\n          brace.nodes.splice(1, 1);\n          brace.nodes.push(first);\n        }\n      }\n\n      brace.push(node);\n    })\n\n    /**\n     * Capture boundary characters\n     */\n\n    .set('boundary', function() {\n      var pos = this.position();\n      var m = this.match(/^[$^](?!\\{)/);\n      if (!m) return;\n      return pos(new Node({\n        type: 'text',\n        val: m[0]\n      }));\n    })\n\n    /**\n     * One or zero, non-comma characters wrapped in braces\n     */\n\n    .set('nobrace', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^\\{[^,]?\\}/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      return pos(new Node({\n        type: 'text',\n        multiplier: 0,\n        val: val\n      }));\n    })\n\n    /**\n     * Text\n     */\n\n    .set('text', function() {\n      var isInside = this.isInside('brace');\n      var pos = this.position();\n      var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside && prev.type === 'brace') {\n        prev.text = prev.text || '';\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: 'text',\n        multiplier: 1,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    });\n};\n\n/**\n * Returns true if the character is an extglob character.\n */\n\nfunction isExtglobChar(ch) {\n  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';\n}\n\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length > 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n\n    isEscaped = (a === '\"' && b === '\"')\n      || (a === \"'\" && b === \"'\")\n      || (a === '`' && b === '`');\n  }\n\n  if (isEscaped && options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n    if (!match || match.indexOf('}') === -1) {\n      match = node.match[0];\n    }\n\n    // replace each set with a single \",\"\n    var val = match.replace(/\\{/g, ',').replace(/\\}/g, '');\n    node.multiplier *= val.length;\n    node.val = '';\n  }\n\n  var simpleText = last.type === 'text'\n    && last.multiplier === 1\n    && node.multiplier === 1\n    && node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}\n"]},"metadata":{},"sourceType":"script"}