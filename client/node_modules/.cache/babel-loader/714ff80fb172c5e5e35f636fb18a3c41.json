{"ast":null,"code":"var util = require('./util');\n\nvar types = require('./types');\n\nvar sets = require('./sets');\n\nvar positions = require('./positions');\n\nmodule.exports = function (regexpStr) {\n  var i = 0,\n      l,\n      c,\n      start = {\n    type: types.ROOT,\n    stack: []\n  },\n      // Keep track of last clause/group and stack.\n  lastGroup = start,\n      last = start.stack,\n      groupStack = [];\n\n  var repeatErr = function (i) {\n    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));\n  }; // Decode a few escaped characters.\n\n\n  var str = util.strToChars(regexpStr);\n  l = str.length; // Iterate through each character in string.\n\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({\n                type: types.REFERENCE,\n                value: parseInt(c, 10)\n              }); // Escaped character.\n            } else {\n              last.push({\n                type: types.CHAR,\n                value: c.charCodeAt(0)\n              });\n            }\n\n        }\n\n        break;\n      // Positionals.\n\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n      // Handle custom sets.\n\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        } // Get all the characters in class.\n\n\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr); // Increase index by length of class.\n\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not: not\n        });\n        break;\n      // Class of any character except \\n.\n\n      case '.':\n        last.push(sets.anyChar());\n        break;\n      // Push group onto stack.\n\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true\n        };\n        c = str[i]; // If if this is a special kind of group.\n\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2; // Match if followed by.\n\n          if (c === '=') {\n            group.followedBy = true; // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n          } else if (c !== ':') {\n            util.error(regexpStr, 'Invalid group, character \\'' + c + '\\' after \\'?\\' at column ' + (i - 1));\n          }\n\n          group.remember = false;\n        } // Insert subgroup into current group stack.\n\n\n        last.push(group); // Remember the current group for when the group closes.\n\n        groupStack.push(lastGroup); // Make this new group the current group.\n\n        lastGroup = group;\n        last = group.stack;\n        break;\n      // Pop group out of stack.\n\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));\n        }\n\n        lastGroup = groupStack.pop(); // Check if this group has a PIPE.\n        // To get back the correct last stack.\n\n        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n      // Use pipe character to give more choices.\n\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        } // Create a new stack and add to options for rest of clause.\n\n\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)),\n            min,\n            max;\n\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n          last.push({\n            type: types.REPETITION,\n            min: min,\n            max: max,\n            value: last.pop()\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123\n          });\n        }\n\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop()\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop()\n        });\n        break;\n      // Default is a character that is not `\\[](){}?+*^$`.\n\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0)\n        });\n    }\n  } // Check if any groups have not been closed.\n\n\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/ret/lib/index.js"],"names":["util","require","types","sets","positions","module","exports","regexpStr","i","l","c","start","type","ROOT","stack","lastGroup","last","groupStack","repeatErr","error","str","strToChars","length","push","wordBoundary","nonWordBoundary","words","notWords","ints","notInts","whitespace","notWhitespace","test","REFERENCE","value","parseInt","CHAR","charCodeAt","begin","end","not","classTokens","tokenizeClass","slice","SET","set","anyChar","group","GROUP","remember","followedBy","notFollowedBy","pop","options","rs","exec","min","max","Infinity","REPETITION"],"mappings":"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","sourcesContent":["var util      = require('./util');\nvar types     = require('./types');\nvar sets      = require('./sets');\nvar positions = require('./positions');\n\n\nmodule.exports = function(regexpStr) {\n  var i = 0, l, c,\n      start = { type: types.ROOT, stack: []},\n\n      // Keep track of last clause/group and stack.\n      lastGroup = start,\n      last = start.stack,\n      groupStack = [];\n\n\n  var repeatErr = function(i) {\n    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n          last.push(positions.begin());\n        break;\n\n      case '$':\n          last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not: not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              'Invalid group, character \\'' + c +\n              '\\' after \\'?\\' at column ' + (i - 1));\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min: min,\n            max: max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n"]},"metadata":{},"sourceType":"script"}