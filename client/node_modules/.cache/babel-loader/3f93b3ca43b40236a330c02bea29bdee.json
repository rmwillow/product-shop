{"ast":null,"code":"'use strict';\n/**\n* Nanomatch compilers\n*/\n\nmodule.exports = function (nanomatch, options) {\n  function slash() {\n    if (options && typeof options.slash === 'string') {\n      return options.slash;\n    }\n\n    if (options && typeof options.slash === 'function') {\n      return options.slash.call(nanomatch);\n    }\n\n    return '\\\\\\\\/';\n  }\n\n  function star() {\n    if (options && typeof options.star === 'string') {\n      return options.star;\n    }\n\n    if (options && typeof options.star === 'function') {\n      return options.star.call(nanomatch);\n    }\n\n    return '[^' + slash() + ']*?';\n  }\n\n  var ast = nanomatch.ast = nanomatch.parser.ast;\n  ast.state = nanomatch.parser.state;\n  nanomatch.compiler.state = ast.state;\n  nanomatch.compiler\n  /**\n   * Negation / escaping\n   */\n  .set('not', function (node) {\n    var prev = this.prev();\n\n    if (this.options.nonegate === true || prev.type !== 'bos') {\n      return this.emit('\\\\' + node.val, node);\n    }\n\n    return this.emit(node.val, node);\n  }).set('escape', function (node) {\n    if (this.options.unescape && /^[-\\w_.]/.test(node.val)) {\n      return this.emit(node.val, node);\n    }\n\n    return this.emit('\\\\' + node.val, node);\n  }).set('quoted', function (node) {\n    return this.emit(node.val, node);\n  })\n  /**\n   * Regex\n   */\n  .set('dollar', function (node) {\n    if (node.parent.type === 'bracket') {\n      return this.emit(node.val, node);\n    }\n\n    return this.emit('\\\\' + node.val, node);\n  })\n  /**\n   * Dot: \".\"\n   */\n  .set('dot', function (node) {\n    if (node.dotfiles === true) this.dotfiles = true;\n    return this.emit('\\\\' + node.val, node);\n  })\n  /**\n   * Slashes: \"/\" and \"\\\"\n   */\n  .set('backslash', function (node) {\n    return this.emit(node.val, node);\n  }).set('slash', function (node, nodes, i) {\n    var val = '[' + slash() + ']';\n    var parent = node.parent;\n    var prev = this.prev(); // set \"node.hasSlash\" to true on all ancestor parens nodes\n\n    while (parent.type === 'paren' && !parent.hasSlash) {\n      parent.hasSlash = true;\n      parent = parent.parent;\n    }\n\n    if (prev.addQmark) {\n      val += '?';\n    } // word boundary\n\n\n    if (node.rest.slice(0, 2) === '\\\\b') {\n      return this.emit(val, node);\n    } // globstars\n\n\n    if (node.parsed === '**' || node.parsed === './**') {\n      this.output = '(?:' + this.output;\n      return this.emit(val + ')?', node);\n    } // negation\n\n\n    if (node.parsed === '!**' && this.options.nonegate !== true) {\n      return this.emit(val + '?\\\\b', node);\n    }\n\n    return this.emit(val, node);\n  })\n  /**\n   * Square brackets\n   */\n  .set('bracket', function (node) {\n    var close = node.close;\n    var open = !node.escaped ? '[' : '\\\\[';\n    var negated = node.negated;\n    var inner = node.inner;\n    var val = node.val;\n\n    if (node.escaped === true) {\n      inner = inner.replace(/\\\\?(\\W)/g, '\\\\$1');\n      negated = '';\n    }\n\n    if (inner === ']-') {\n      inner = '\\\\]\\\\-';\n    }\n\n    if (negated && inner.indexOf('.') === -1) {\n      inner += '.';\n    }\n\n    if (negated && inner.indexOf('/') === -1) {\n      inner += '/';\n    }\n\n    val = open + negated + inner + close;\n    return this.emit(val, node);\n  })\n  /**\n   * Square: \"[.]\" (only matches a single character in brackets)\n   */\n  .set('square', function (node) {\n    var val = (/^\\W/.test(node.val) ? '\\\\' : '') + node.val;\n    return this.emit(val, node);\n  })\n  /**\n   * Question mark: \"?\"\n   */\n  .set('qmark', function (node) {\n    var prev = this.prev(); // don't use \"slash\" variable so that we always avoid\n    // matching backslashes and slashes with a qmark\n\n    var val = '[^.\\\\\\\\/]';\n\n    if (this.options.dot || prev.type !== 'bos' && prev.type !== 'slash') {\n      val = '[^\\\\\\\\/]';\n    }\n\n    if (node.parsed.slice(-1) === '(') {\n      var ch = node.rest.charAt(0);\n\n      if (ch === '!' || ch === '=' || ch === ':') {\n        return this.emit(node.val, node);\n      }\n    }\n\n    if (node.val.length > 1) {\n      val += '{' + node.val.length + '}';\n    }\n\n    return this.emit(val, node);\n  })\n  /**\n   * Plus\n   */\n  .set('plus', function (node) {\n    var prev = node.parsed.slice(-1);\n\n    if (prev === ']' || prev === ')') {\n      return this.emit(node.val, node);\n    }\n\n    if (!this.output || /[?*+]/.test(ch) && node.parent.type !== 'bracket') {\n      return this.emit('\\\\+', node);\n    }\n\n    var ch = this.output.slice(-1);\n\n    if (/\\w/.test(ch) && !node.inside) {\n      return this.emit('+\\\\+?', node);\n    }\n\n    return this.emit('+', node);\n  })\n  /**\n   * globstar: '**'\n   */\n  .set('globstar', function (node, nodes, i) {\n    if (!this.output) {\n      this.state.leadingGlobstar = true;\n    }\n\n    var prev = this.prev();\n    var before = this.prev(2);\n    var next = this.next();\n    var after = this.next(2);\n    var type = prev.type;\n    var val = node.val;\n\n    if (prev.type === 'slash' && next.type === 'slash') {\n      if (before.type === 'text') {\n        this.output += '?';\n\n        if (after.type !== 'text') {\n          this.output += '\\\\b';\n        }\n      }\n    }\n\n    var parsed = node.parsed;\n\n    if (parsed.charAt(0) === '!') {\n      parsed = parsed.slice(1);\n    }\n\n    var isInside = node.isInside.paren || node.isInside.brace;\n\n    if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {\n      val = star();\n    } else {\n      val = this.options.dot !== true ? '(?:(?!(?:[' + slash() + ']|^)\\\\.).)*?' : '(?:(?!(?:[' + slash() + ']|^)(?:\\\\.{1,2})($|[' + slash() + ']))(?!\\\\.{2}).)*?';\n    }\n\n    if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {\n      val = '(?!\\\\.)' + val;\n    }\n\n    if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {\n      if (after.type === 'text' || after.type === 'star') {\n        node.addQmark = true;\n      }\n    }\n\n    if (this.options.capture) {\n      val = '(' + val + ')';\n    }\n\n    return this.emit(val, node);\n  })\n  /**\n   * Star: \"*\"\n   */\n  .set('star', function (node, nodes, i) {\n    var prior = nodes[i - 2] || {};\n    var prev = this.prev();\n    var next = this.next();\n    var type = prev.type;\n\n    function isStart(n) {\n      return n.type === 'bos' || n.type === 'slash';\n    }\n\n    if (this.output === '' && this.options.contains !== true) {\n      this.output = '(?![' + slash() + '])';\n    }\n\n    if (type === 'bracket' && this.options.bash === false) {\n      var str = next && next.type === 'bracket' ? star() : '*?';\n\n      if (!prev.nodes || prev.nodes[1].type !== 'posix') {\n        return this.emit(str, node);\n      }\n    }\n\n    var prefix = !this.dotfiles && type !== 'text' && type !== 'escape' ? this.options.dot ? '(?!(?:^|[' + slash() + '])\\\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\\\.)' : '';\n\n    if (isStart(prev) || isStart(prior) && type === 'not') {\n      if (prefix !== '(?!\\\\.)') {\n        prefix += '(?!(\\\\.{2}|\\\\.[' + slash() + ']))(?=.)';\n      } else {\n        prefix += '(?=.)';\n      }\n    } else if (prefix === '(?!\\\\.)') {\n      prefix = '';\n    }\n\n    if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {\n      this.output = '(?!\\\\.)' + this.output;\n    }\n\n    var output = prefix + star();\n\n    if (this.options.capture) {\n      output = '(' + output + ')';\n    }\n\n    return this.emit(output, node);\n  })\n  /**\n   * Text\n   */\n  .set('text', function (node) {\n    return this.emit(node.val, node);\n  })\n  /**\n   * End-of-string\n   */\n  .set('eos', function (node) {\n    var prev = this.prev();\n    var val = node.val;\n    this.output = '(?:\\\\.[' + slash() + '](?=.))?' + this.output;\n\n    if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {\n      val += this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)';\n    }\n\n    return this.emit(val, node);\n  });\n  /**\n   * Allow custom compilers to be passed on options\n   */\n\n  if (options && typeof options.compilers === 'function') {\n    options.compilers(nanomatch.compiler);\n  }\n};","map":{"version":3,"sources":["/Users/rachelmcgrath/Desktop/projects/product-shop/client/node_modules/nanomatch/lib/compilers.js"],"names":["module","exports","nanomatch","options","slash","call","star","ast","parser","state","compiler","set","node","prev","nonegate","type","emit","val","unescape","test","parent","dotfiles","nodes","i","hasSlash","addQmark","rest","slice","parsed","output","close","open","escaped","negated","inner","replace","indexOf","dot","ch","charAt","length","inside","leadingGlobstar","before","next","after","isInside","paren","brace","capture","prior","isStart","n","contains","bash","str","prefix","metachar","compilers"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n* Nanomatch compilers\n*/\n\nmodule.exports = function(nanomatch, options) {\n  function slash() {\n    if (options && typeof options.slash === 'string') {\n      return options.slash;\n    }\n    if (options && typeof options.slash === 'function') {\n      return options.slash.call(nanomatch);\n    }\n    return '\\\\\\\\/';\n  }\n\n  function star() {\n    if (options && typeof options.star === 'string') {\n      return options.star;\n    }\n    if (options && typeof options.star === 'function') {\n      return options.star.call(nanomatch);\n    }\n    return '[^' + slash() + ']*?';\n  }\n\n  var ast = nanomatch.ast = nanomatch.parser.ast;\n  ast.state = nanomatch.parser.state;\n  nanomatch.compiler.state = ast.state;\n  nanomatch.compiler\n\n    /**\n     * Negation / escaping\n     */\n\n    .set('not', function(node) {\n      var prev = this.prev();\n      if (this.options.nonegate === true || prev.type !== 'bos') {\n        return this.emit('\\\\' + node.val, node);\n      }\n      return this.emit(node.val, node);\n    })\n    .set('escape', function(node) {\n      if (this.options.unescape && /^[-\\w_.]/.test(node.val)) {\n        return this.emit(node.val, node);\n      }\n      return this.emit('\\\\' + node.val, node);\n    })\n    .set('quoted', function(node) {\n      return this.emit(node.val, node);\n    })\n\n    /**\n     * Regex\n     */\n\n    .set('dollar', function(node) {\n      if (node.parent.type === 'bracket') {\n        return this.emit(node.val, node);\n      }\n      return this.emit('\\\\' + node.val, node);\n    })\n\n    /**\n     * Dot: \".\"\n     */\n\n    .set('dot', function(node) {\n      if (node.dotfiles === true) this.dotfiles = true;\n      return this.emit('\\\\' + node.val, node);\n    })\n\n    /**\n     * Slashes: \"/\" and \"\\\"\n     */\n\n    .set('backslash', function(node) {\n      return this.emit(node.val, node);\n    })\n    .set('slash', function(node, nodes, i) {\n      var val = '[' + slash() + ']';\n      var parent = node.parent;\n      var prev = this.prev();\n\n      // set \"node.hasSlash\" to true on all ancestor parens nodes\n      while (parent.type === 'paren' && !parent.hasSlash) {\n        parent.hasSlash = true;\n        parent = parent.parent;\n      }\n\n      if (prev.addQmark) {\n        val += '?';\n      }\n\n      // word boundary\n      if (node.rest.slice(0, 2) === '\\\\b') {\n        return this.emit(val, node);\n      }\n\n      // globstars\n      if (node.parsed === '**' || node.parsed === './**') {\n        this.output = '(?:' + this.output;\n        return this.emit(val + ')?', node);\n      }\n\n      // negation\n      if (node.parsed === '!**' && this.options.nonegate !== true) {\n        return this.emit(val + '?\\\\b', node);\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Square brackets\n     */\n\n    .set('bracket', function(node) {\n      var close = node.close;\n      var open = !node.escaped ? '[' : '\\\\[';\n      var negated = node.negated;\n      var inner = node.inner;\n      var val = node.val;\n\n      if (node.escaped === true) {\n        inner = inner.replace(/\\\\?(\\W)/g, '\\\\$1');\n        negated = '';\n      }\n\n      if (inner === ']-') {\n        inner = '\\\\]\\\\-';\n      }\n\n      if (negated && inner.indexOf('.') === -1) {\n        inner += '.';\n      }\n      if (negated && inner.indexOf('/') === -1) {\n        inner += '/';\n      }\n\n      val = open + negated + inner + close;\n      return this.emit(val, node);\n    })\n\n    /**\n     * Square: \"[.]\" (only matches a single character in brackets)\n     */\n\n    .set('square', function(node) {\n      var val = (/^\\W/.test(node.val) ? '\\\\' : '') + node.val;\n      return this.emit(val, node);\n    })\n\n    /**\n     * Question mark: \"?\"\n     */\n\n    .set('qmark', function(node) {\n      var prev = this.prev();\n      // don't use \"slash\" variable so that we always avoid\n      // matching backslashes and slashes with a qmark\n      var val = '[^.\\\\\\\\/]';\n      if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {\n        val = '[^\\\\\\\\/]';\n      }\n\n      if (node.parsed.slice(-1) === '(') {\n        var ch = node.rest.charAt(0);\n        if (ch === '!' || ch === '=' || ch === ':') {\n          return this.emit(node.val, node);\n        }\n      }\n\n      if (node.val.length > 1) {\n        val += '{' + node.val.length + '}';\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Plus\n     */\n\n    .set('plus', function(node) {\n      var prev = node.parsed.slice(-1);\n      if (prev === ']' || prev === ')') {\n        return this.emit(node.val, node);\n      }\n      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {\n        return this.emit('\\\\+', node);\n      }\n      var ch = this.output.slice(-1);\n      if (/\\w/.test(ch) && !node.inside) {\n        return this.emit('+\\\\+?', node);\n      }\n      return this.emit('+', node);\n    })\n\n    /**\n     * globstar: '**'\n     */\n\n    .set('globstar', function(node, nodes, i) {\n      if (!this.output) {\n        this.state.leadingGlobstar = true;\n      }\n\n      var prev = this.prev();\n      var before = this.prev(2);\n      var next = this.next();\n      var after = this.next(2);\n      var type = prev.type;\n      var val = node.val;\n\n      if (prev.type === 'slash' && next.type === 'slash') {\n        if (before.type === 'text') {\n          this.output += '?';\n\n          if (after.type !== 'text') {\n            this.output += '\\\\b';\n          }\n        }\n      }\n\n      var parsed = node.parsed;\n      if (parsed.charAt(0) === '!') {\n        parsed = parsed.slice(1);\n      }\n\n      var isInside = node.isInside.paren || node.isInside.brace;\n      if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {\n        val = star();\n      } else {\n        val = this.options.dot !== true\n          ? '(?:(?!(?:[' + slash() + ']|^)\\\\.).)*?'\n          : '(?:(?!(?:[' + slash() + ']|^)(?:\\\\.{1,2})($|[' + slash() + ']))(?!\\\\.{2}).)*?';\n      }\n\n      if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {\n        val = '(?!\\\\.)' + val;\n      }\n\n      if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {\n        if (after.type === 'text' || after.type === 'star') {\n          node.addQmark = true;\n        }\n      }\n\n      if (this.options.capture) {\n        val = '(' + val + ')';\n      }\n\n      return this.emit(val, node);\n    })\n\n    /**\n     * Star: \"*\"\n     */\n\n    .set('star', function(node, nodes, i) {\n      var prior = nodes[i - 2] || {};\n      var prev = this.prev();\n      var next = this.next();\n      var type = prev.type;\n\n      function isStart(n) {\n        return n.type === 'bos' || n.type === 'slash';\n      }\n\n      if (this.output === '' && this.options.contains !== true) {\n        this.output = '(?![' + slash() + '])';\n      }\n\n      if (type === 'bracket' && this.options.bash === false) {\n        var str = next && next.type === 'bracket' ? star() : '*?';\n        if (!prev.nodes || prev.nodes[1].type !== 'posix') {\n          return this.emit(str, node);\n        }\n      }\n\n      var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'\n        ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\\\.)')\n        : '';\n\n      if (isStart(prev) || (isStart(prior) && type === 'not')) {\n        if (prefix !== '(?!\\\\.)') {\n          prefix += '(?!(\\\\.{2}|\\\\.[' + slash() + ']))(?=.)';\n        } else {\n          prefix += '(?=.)';\n        }\n      } else if (prefix === '(?!\\\\.)') {\n        prefix = '';\n      }\n\n      if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {\n        this.output = '(?!\\\\.)' + this.output;\n      }\n\n      var output = prefix + star();\n      if (this.options.capture) {\n        output = '(' + output + ')';\n      }\n\n      return this.emit(output, node);\n    })\n\n    /**\n     * Text\n     */\n\n    .set('text', function(node) {\n      return this.emit(node.val, node);\n    })\n\n    /**\n     * End-of-string\n     */\n\n    .set('eos', function(node) {\n      var prev = this.prev();\n      var val = node.val;\n\n      this.output = '(?:\\\\.[' + slash() + '](?=.))?' + this.output;\n      if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {\n        val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');\n      }\n\n      return this.emit(val, node);\n    });\n\n  /**\n   * Allow custom compilers to be passed on options\n   */\n\n  if (options && typeof options.compilers === 'function') {\n    options.compilers(nanomatch.compiler);\n  }\n};\n\n"]},"metadata":{},"sourceType":"script"}